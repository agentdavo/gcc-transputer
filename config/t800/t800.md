;; GCC machine description for INMOS transputer family
;; Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
;;
;; Written by Yury Shevchuk <sizif@botik.ru>
;;
;; This file is part of GNU CC.
;;
;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.
;;
;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.  */


/* This file is divided into sections that correspond to the standard
   pattern names.  Sections are ordered along the manual (Using and
   Porting GNU CC, "14.7 Standard Names for Patterns Used in Generation").  */

/* Now that this file wants to be run through CPP, we use C style
   comments: CPP doesn't honor LISP-style comments and so gets upset
   by unpaired ', like the one above. */

/* Operand classes for the register allocator:
     'r' any register of integer reg-stack
     'a' Areg (reg 0)
     'b' Breg (reg 1)
     'c' Creg (reg 2)
     'f' any register of floating reg-stack
     't' FAreg (reg 3)
     'u' FBreg (reg 4)
     'v' FCreg (reg 5)  */

/* Output template additional format letters are:
     'w' convert byte offset to word offset (divide by UNITS_PER_WORD);
     the offset is checked to be a multiple of UNITS_PER_WORD;

     'q' result of division of the operand by UNITS_PER_WORD; this is
     the same as 'w' except that this will not abort if given an
     operand which is not a multiple of UNITS_PER_WORD;

     'r' remainder from division the operand by UNITS_PER_WORD;  */

/* Notes:

 * `fpu...' instructions are doubly indirect; opcode for them
should be pushed onto the integer reg-stack and then `fpentry'
command executed. This is done implicitly by assembler; however, we
should ensure that there is room in the reg-stack for push to be safe.
We achieve this by adding (clobber (match_scratch:SI "=&r")) in
patterns for such commands.

(T9000 does not need this)

 * Using (clobber (reg ...)) should be avoided, especially when
this reg is also an input for the insn: an ugliest code results. Use
(clobber (match_scratch:SI N "=&r")) instead.  */


/* POPPED_INPUTS attribute shows whether the insn pops some input
   register. Its value is the bit mask for operand numbers; e.g.
   get_attr_popped_inputs() == 6 means that registers that are operand
   1 and operand 2 are implicitly popped by this insn.  This is used
   from INSN_CLOBBERS_REGNO_P macro.  */

(define_attr "popped_inputs" "" (const_int 0))

/* POPPED_INPUTS_ON_JUMP attribute shows what inputs are popped by a
   jump insn when the jump is taken. The behaviour in the case when
   the jump is not taken is described by POPPED_INPUTS attribute.  If
   you do not use POPPED_INPUTS_ON_JUMP attribute at all, jump insns
   are supposed to pop identically in either case.  */

(define_attr "popped_inputs_on_jump" "" (const_int 0))


;;------------------------------
;; movM
;;------------------------------

/* Instructions used for SImode moves 

 src\dest             REG     local mem    nonlocal mem
REG                   dup      stl          stnl
CONST_INT             ldc       -            -
SYMBOL_REF, LABEL_REF ldpi      -            -
local memory          ldl       -            -
nonlocal memory       ldnl      -            -
Wreg                  ldlp      -            -

- Loading Wreg unsupported, being within the competence of
  prologue/epilogue only;
- Moving SImode to/from float-point registers unsupported;
  HARD_REGNO_MODE_OK rejects MODE_INT for float-point registers.  */


(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand" "")
        (match_operand:SI 1 "general_operand" ""))]
  ""
  "{
    /* transputers can move to memory only from a general reg */
    if (GET_CODE (operands[0]) == MEM)
      {
	if (! ABCreg_operand (operands[1], VOIDmode))
          operands[1] = copy_to_mode_reg (SImode, operands[1]);
      }

    /* In dataseg-by-pointer model, if src is a SYMBOL_REF/v
       (i.e. referring to data segment), it needs to be added the
       dataseg start pointer */

    if (TARGET_DATASEG_BY_POINTER
        && ((GET_CODE (operands[1]) == SYMBOL_REF
             && SYMBOL_REF_FLAG (operands[1]) == 1)
            || (GET_CODE (operands[1]) == CONST
                && t800_dataseg_symrefs_mentioned_p (XEXP (operands[1], 0)))))
        {
	  rtx temp;

          /* Don't use pseudo for temp when dest is a hard register,
             to make the generated sequence reload-safe. */

	  if (reload_in_progress
              || ((GET_CODE (operands[0]) == REG
                   && REGNO (operands[0]) <= R_CREG)
                  || (GET_CODE (operands[0]) == SUBREG
                      && GET_CODE (SUBREG_REG (operands[0])) == REG
                      && REGNO (SUBREG_REG (operands[0])) < R_CREG)))
            temp = operands[0];
          else
            temp = gen_reg_rtx (Pmode);

          emit_move_insn (temp, T800_DATASEG_START_RTX);
	  operands[1] = gen_rtx (PLUS, Pmode, temp, operands[1]);
	  /* to match ldnlp or adc */
	}

    /* If dst is a hard register prior to reload, we must be loading
       register arguments before a call or return.  The compiler
       assumes that the insns we generate for this never need
       reloading; being unaware about what is already loaded in
       registers, reload pass can use one of them for reloading, thus
       breaking the loaded value.  So take care to generate
       reload-safe insns here, sigh.  */

    else if (!reload_in_progress && !reload_completed
             && ((GET_CODE (operands[0]) == REG
                  && REGNO (operands[0]) <= R_CREG)
                 || (GET_CODE (operands[0]) == SUBREG
                     && GET_CODE (SUBREG_REG (operands[0])) == REG
                     && REGNO (SUBREG_REG (operands[0])) < R_CREG))
             && nonlocal_plus_operand (operands[1], SImode))
      {

        /* We make sure the insn will need no reloading by copying the
           nonlocal memory address register into a *hard* register --
           the one we are asked to load into.  */

	rtx temp = operands[0];

	if (GET_CODE (temp) == SUBREG)
          temp = alter_subreg (temp);

        if (GET_CODE (XEXP (operands[1], 0)) == REG)
          {
            emit_move_insn (temp, XEXP (operands[1], 0));
            operands[1] = gen_rtx (MEM, SImode, temp);
          }
        else if (GET_CODE (XEXP (operands[1], 0)) == PLUS)
          {
            emit_move_insn (temp, XEXP (XEXP (operands[1], 0), 0));
            operands[1] = gen_rtx (MEM, SImode,
                                   gen_rtx (PLUS, SImode,
                                            temp,
                                            XEXP (XEXP (operands[1], 0), 1)));
          }
        else
          abort ();
      }

    /* No special care is taken for the case when either of operands
       is a pseudo and reload is in progress (which means the pseudo
       is actually a stack slot).  We're sure the default pattern we
       generate will match either `ldl' or `stl', because in the moves
       generated by reload one of the operands is always a hard register.  */
}")


(define_expand "movhi"
  [(set (match_operand:HI 0 "general_operand" "")
        (match_operand:HI 1 "general_operand" ""))]
  ""
  "if (TARGET_HAVE_SIXTEEN) {

    /* Transputers can move to memory only from a reg */
    if (GET_CODE (operands[0]) == MEM)
      {
        if (! reg_p (operands[1]))
          {
            rtx temp = gen_reg_rtx (HImode);
            emit_move_insn (temp, operands[1]);
            operands[1] = temp;
          }

        /* Now source is a HImode REG, dest is a HImode MEM.
           This will match `ss', but ensure that destination
           MEM address is an ABCreg.  */
        if (! ABCreg_operand (XEXP (operands[0], 0), SImode))
          operands[0] = gen_rtx (MEM, HImode,
                                 copy_addr_to_reg (XEXP (operands[0], 0)));
      }
    else
      {
        /* Destination is a REG. All loading insns yield a SImode
           value, so change dest to SImode.  */

        operands[0] = gen_lowpart (SImode, operands[0]);

        if (GET_CODE (operands[1]) == MEM)
          {
            rtx addr = XEXP (operands[1], 0);

            /* If we are loading a local half-word aligned on a word
               boundary, we may use `ldl' instead of `ls'.  */

            if (local_operand_address (addr, SImode))
              operands[1] = change_address (operands[1], SImode, addr);
            else
              /* Otherwise, arrange to match `ls'.  */
              {
                if (! ABCreg_operand (addr, Pmode))
                  {
                    rtx temp = reload_in_progress? operands[0]
                                                 : gen_reg_rtx (Pmode);
                    emit_move_insn (temp, addr);
                    operands[1] = change_address (operands[1], VOIDmode, temp);
                  }
                operands[1] = gen_rtx (ZERO_EXTEND, SImode, operands[1]);
              }
          }
        else
          {
            /* Src is CONST_INT or REG; just change src to SImode, and
               word insns will match */
            operands[1] = gen_lowpart (SImode, operands[1]);
            /* to match `ldc' or `dup' */
          }

        /* Failed pseudos during reload end up with
             (set (reg:SI hard) (subreg:SI (reg:HI pseudo))),
           which matches `ldl', or with
             (set (subreg:SI (reg:HI pseudo)) (reg:SI hard)),
           which matches `stl'.  */
      }
   }
   else {
    if (GET_CODE (operands[0]) == MEM)
      {
        rtx addr = XEXP (operands[0], 0);
        rtx addr2, store_byte, addr_plus_one;

	/* Storing HImode.  On transputers without 16-bit support, we
	   have to do this by shifts and byte stores. */

        /* Examine src first.  If it is CONST_INT, we can shift it in
           compile time; otherwise, we force it to register and generate
           runtime shift later.  */

        if (GET_CODE (operands[1]) != CONST_INT
       	    && ! ABCreg_operand (operands[1], HImode))
          operands[1] = copy_to_reg (operands[1]);

	/* Get the address of destination MEM into ABCreg, if it is
           not in one.  We don't try to keep symbol_ref addresses to
           compute address of the second byte in compile time, because
           loading symbol_ref is more expensive than run-time constant
           addition.  */

        if ( ! ABCreg_operand (addr, Pmode))
          addr = copy_to_reg (addr);

        /* Make a copy of the address in yet another pseudo for use in
           second `sb'; the first one will be popped by the first `sb' */

        addr2 = copy_to_reg (addr);

        /* Get src into a reg now.  We don't attempt to make a copy of
          it like we did for the dest address, because there's no enough
          room on integer reg-stack so it would go to stack slot
          anyway. */

        if (GET_CODE (operands[1]) == CONST_INT)
          {
            /* We mask the constant to make it cheaper. */
            int val = INTVAL (operands[1]) & 0xff;
            store_byte = copy_to_mode_reg (QImode, GEN_INT (val));
          }
        else
          store_byte = gen_lowpart (QImode, operands[1]);

        /* Emit the first `sb' */

        emit_move_insn (change_address (operands[0], QImode, addr2),
                        store_byte);

        /* Prepare the value for second `sb' by shifting the original
           src right by 8 bits. */

        if (GET_CODE (operands[1]) == CONST_INT)
          {
            /* We mask the constant to make it cheaper. */
            int val = (INTVAL (operands[1]) >> 8) & 0xff;
            store_byte = copy_to_mode_reg (QImode, GEN_INT (val));
          }
        else
          {
            rtx temp = gen_reg_rtx (SImode);
            emit_insn (gen_lshrsi3 (temp,
                                    gen_lowpart (SImode, operands[1]),
                                    copy_to_mode_reg (SImode, GEN_INT (8))));
            store_byte = gen_lowpart (QImode, temp);
          }

        /* Prepare address for 2nd `sb' by incrementing address by 1 */
      
        addr_plus_one = gen_reg_rtx (SImode);
        emit_insn (gen__adc (addr_plus_one, addr, GEN_INT (1)));

        /* Emit the 2nd `sb' */

        emit_move_insn (change_address (operands[0], QImode, addr_plus_one),
                        store_byte);
        DONE;
      }
    else
      {
        /* Destination is a REG. All loading insns yield a SImode
           value, so make it into SImode subreg */

        operands[0] = gen_lowpart (SImode, operands[0]);

        if (GET_CODE (operands[1]) == MEM)
          {
            rtx addr = XEXP (operands[1], 0);

            /* If we are loading a local halfword aligned on the word
               boundary, we may use `ldl'.  */

            if (local_operand_address (addr, SImode))
              {
                operands[1] = change_address (operands[1], SImode, addr);
                /* to match `ldl' */
              }

            /* If we are loading a halfword addressed by symbol_ref,
               we can go with word load (ldnl) as well, because we
               assume symbol_refs to be word-aligned.

               ??? should accept word-aligned CONSTs, too, but it
               requires a predicate to distingwish them from unaligned
               CONSTs.  */

            else if (GET_CODE (addr) == SYMBOL_REF)
              {
                operands[1] = change_address (operands[1], SImode,
                                              copy_to_reg (addr));
                /* to match `ldnl' */
              }

            /* Otherwise, do the load in two `lb's */

            else
              {
                rtx byte1 = gen_reg_rtx (SImode);
                rtx byte2 = gen_reg_rtx (SImode);
                rtx temp  = gen_reg_rtx (SImode);
                rtx addr_plus_one;
                rtx addr2;

		/* Get the address of destination MEM into ABCreg, if
                   it is not in one.  We don't try to keep symbol_ref
                   addresses to compute address of the second byte in
                   compile time, because loading symbol_ref is more
                   expensive than run-time constant addition.  */

		if ( ! ABCreg_operand (addr, Pmode))
		  addr = copy_to_reg (addr);

		/* Make a copy of the address in yet another pseudo
                   for use in second `lb'; the first one will be
                   popped by the first `lb' */

		addr2 = copy_to_reg (addr);

		emit_insn (gen__lb (byte1,
                  change_address (operands[1], QImode, addr2)));
                addr_plus_one = gen_reg_rtx (SImode);
		emit_insn (gen__adc (addr_plus_one, addr, GEN_INT (1)));
                emit_insn (gen__lb (byte2,
                  change_address (operands[1], QImode, addr_plus_one)));
                emit_insn (gen_ashlsi3 (temp, byte2,
                  copy_to_mode_reg (SImode, GEN_INT (8))));
                emit_insn (gen_iorsi3 (gen_lowpart (SImode, operands[0]),
                                       temp, byte1));
		DONE;
              }
          }
        else
          {
            /* Src is CONST_INT or REG; just change src to SImode, and
               word insns will match */
            operands[1] = gen_lowpart (SImode, operands[1]);
            /* to match `ldc' or `dup' */
          }

        /* Failed pseudos during reload end up with
             (set (reg:SI hard) (subreg:SI (reg:HI pseudo))),
           which matches `ldl', or with
             (set (subreg:SI (reg:HI pseudo)) (reg:SI hard)),
           which matches `stl'.  */
      }
  }
")


/* Instructions used for QImode moves

                      REG              local mem    nonlocal mem
REG                   dup    (SI>SI)     sb (QI>QI)   sb (QI>QI)
CONST_INT             ldc    (VOID>SI)   -            -
SYMBOL_REF, LABEL_REF ldpi   (SI>SI)     -            -
local memory          lb/ldl (QI/SI>SI)  -            -
nonlocal memory       lb     (QI>SI)     -            -

*/

(define_expand "movqi"
  [(set (match_operand:QI 0 "general_operand" "")
        (match_operand:QI 1 "general_operand" ""))]
  ""
  "{
    /* transputers can move to memory only from a reg */
    if (GET_CODE (operands[0]) == MEM)
      {
        if (! reg_p (operands[1]))
          {
            rtx temp = gen_reg_rtx (QImode);
            emit_move_insn (temp, operands[1]);
            operands[1] = temp;
          }

        /* Now source is a QImode REG, dest is a QImode MEM.
           This will match `sb', but ensure that destination
           MEM address is an ABCreg.  */
        if (! ABCreg_operand (XEXP (operands[0], 0), SImode))
          operands[0] = gen_rtx (MEM, QImode,
                                 copy_addr_to_reg (XEXP (operands[0], 0)));
      }
    else
      {
        /* Destination is a REG. All loading insns yield a SImode
           value, so change dest to SImode.  */

        operands[0] = gen_lowpart (SImode, operands[0]);

        if (GET_CODE (operands[1]) == MEM)
          {
            rtx addr = XEXP (operands[1], 0);

            /* If we are loading a local byte aligned on a word
               boundary, we may use `ldl' instead of `lb'.  */
            if (local_operand_address (addr, Pmode))
              operands[1] = change_address (operands[1], SImode, addr);
            else
              /* Otherwise, arrange to match `lb'.  */
              {
                if (! ABCreg_operand (addr, Pmode))
                  {
                    rtx temp = reload_in_progress? operands[0]
                                                 : gen_reg_rtx (Pmode);
                    emit_move_insn (temp, addr);
                    operands[1] = change_address (operands[1], VOIDmode, temp);
                  }
                operands[1] = gen_rtx (ZERO_EXTEND, SImode, operands[1]);
              }
          }
        else
          {
            /* Src is CONST_INT or REG; just change src to SImode, and
               word insns will match */
            operands[1] = gen_lowpart (SImode, operands[1]);
            /* to match `ldc' or `dup' */
          }

        /* Failed pseudos during reload end up with
             (set (reg:SI hard) (subreg:SI (reg:QI pseudo))),
           which matches `ldl', or with
             (set (subreg:SI (reg:QI pseudo)) (reg:SI hard)),
           which matches `stl'.  */
      }
}")


/* Instructions for FP moves

 src\dest             REG              nonlocal mem
REG                   fpdup             fpstnl{sn,db}
CONST_DOUBLE (== 0)   fpldzero{sn,db}   -
nonlocal memory       fpldnl{sn,db}[i]  -     */

(define_expand "movsf"
  [(set (match_operand:SF 0 "general_operand" "")
        (match_operand:SF 1 "general_operand" ""))]
  ""
  "{
    rtx t800_temp_slot (enum machine_mode);
    rtx t800_force_nonlocal (rtx);

    switch (t800_fp_reg_p (operands[0]) | t800_fp_reg_p (operands[1]) << 1)
      {
      case 0:

        /* Neither operand is an fp register. Do the move with SImode
           insn(s) */

        emit_move_insn (operand_subword (operands[0], 0, 1, SFmode),
                        operand_subword (operands[1], 0, 1, SFmode));
        DONE;

      case 1:

        /* dest is an fp register, src is not.  See if src is an
           integer register: there is no insn to do such move
           directly, so use a temporary stack slot.  */

        if (REG_P (operands[1]))
          {
            rtx temp = t800_temp_slot (SFmode);

            emit_move_insn (temp, operands[1]);
            operands[1] = temp;
          }
	
        /* if src is a MEM, make sure it is a valid nonlocal MEM
           (i.e. address in a general reg) */

	if (GET_CODE (operands[1]) == MEM)
          operands[1] = t800_force_nonlocal (operands[1]);

        break;

      case 2:

        /* src is an fp register, dest is not.  Likewise...  */
        
        if (REG_P (operands[0]))
          {
	    emit_insn (gen_sf_to_ABCreg (operands[0], operands[1],
                                         t800_temp_slot (SFmode)));
            DONE;
          }
	else if (GET_CODE (operands[0]) == MEM)
          operands[0] = t800_force_nonlocal (operands[0]);
        break;

      case 3:

        /* both src and dst are fp registers.  Default pattern will do... */

        break;
      }

    /* Now it should be OK with the default pattern. */
}")

(define_expand "movdf"
  [(set (match_operand:DF 0 "general_operand" "")
        (match_operand:DF 1 "general_operand" ""))]
  ""
  "{
    rtx t800_temp_slot (enum machine_mode);
    rtx t800_force_nonlocal (rtx);

    switch (t800_fp_reg_p (operands[0]) | t800_fp_reg_p (operands[1]) << 1)
      {
      case 0:

        /* Neither operand is an fp register. Do the move with SImode
           insn(s) */

        emit_move_insn (operand_subword (operands[0], 0, 1, DFmode),
                        operand_subword (operands[1], 0, 1, DFmode));
        emit_move_insn (operand_subword (operands[0], 1, 1, DFmode),
                        operand_subword (operands[1], 1, 1, DFmode));
        DONE;

      case 1:

        /* dest is an fp register, src is not.  See if src is an
           integer register: there is no insn to do such move
           directly, so use a temporary stack slot.  */

        if (REG_P (operands[1]))
          {
            rtx temp = t800_temp_slot (DFmode);

            emit_move_insn (temp, operands[1]);
            operands[1] = temp;
          }
	
        /* if src is a MEM, make sure it is a valid nonlocal MEM
           (i.e. address in a general reg) */

	if (GET_CODE (operands[1]) == MEM)
          {
            operands[1] = t800_force_nonlocal (operands[1]);
          }
        break;

      case 2:

        /* src is an fp register, dest is not. */
        
        if (REG_P (operands[0]))
          {
	    emit_insn (gen_df_to_ABCreg (operands[0], operands[1],
                                         t800_temp_slot (DFmode)));
            DONE;
          }
	else if (GET_CODE (operands[0]) == MEM)
          {
            operands[0] = t800_force_nonlocal (operands[0]);
          }
        break;
      }

    /* Now it should be OK with the default pattern. */
}")




/* ldc */

/* {symbol,label}_ref's are not loaded by this, since it would yield
   utterly position-dependent code with a lot of load-time patches.

   ??? rewrite to make more use from mint */

(define_insn "_ldc"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (match_operand 1 "const_int_operand" ""))]
  ""
  "*return INTVAL (operands[1]) == 0x80000000
      ? \"mint\"
      : \"ldc %1\";")

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (match_operand 1 "const_offset_operand" ""))]
  ""
  "ldc %1")

/* The following two patterns are never generated by anything in
   mov_optab, but they can occasionally pop up as a result of fixing
   rtl after putting a variable into stack (fixup_var_refs_1()).  It
   seems better to kludge aroung the problem here than to hack
   function.c with risk to disturb other machines.

   (The problem exposes on enquire.c when compiling with -O). */

(define_insn ""
  [(set (match_operand:HI 0 "ABCreg_operand" "=a")
        (match_operand 1 "const_int_operand" ""))]
  ""
  "ldc %1")

(define_insn ""
  [(set (match_operand:QI 0 "ABCreg_operand" "=a")
        (match_operand 1 "const_int_operand" ""))]
  ""
  "ldc %1")


/* ldpi */

(define_insn "_ldpi"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (match_operand:SI 1 "ldpi_operand" ""))]
  ""
  "*{
#ifdef T800_LDC_SYMBOL_PC_RELATIVE
  return \"ldc %1-2\;ldpi\";
#else
  return \"ldc %1-LF%=\;ldpi\\nLF%=:\";
#endif
}")

(define_insn "_ldpi2"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (plus:SI (match_operand:SI 1 "ABCreg_operand" "0")
                 (match_operand:SI 2 "ldpi_operand" "")))]
  "T800_AS_ADC_LABELDIFF_OK"
  "adc %2-LF%=\;ldpi\\nLF%=:")


/* `ldl' and `stl' should come ahead of `dup'; otherwise a move
   between a pseudo and hard reg when reload_in_progress could match
   `dup' because ABCreg_operand accepts pseudos even then.  */

/* ldl */

(define_insn "_ldl"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (match_operand:SI 1 "local_operand" ""))]
  ""
  "ldl %w1")


/* stl */

(define_insn "_stl"
  [(set (match_operand:SI 0 "local_operand" "")
        (match_operand:SI 1 "ABCreg_operand" "a"))]
  ""
  "stl %w0"
  [(set (attr "popped_inputs") (const_int 2))])


/* dup */

/* This matches any inter-general-reg move.

  ??? `&' constraint for operand 0 is currently required by reg-stack2.c
  to present for any output if the insn has non-popped inputs. (*** &)

  Now, _dup is allowed to have no earlyclobber by INSN_OK_FOR_RULE_3.
  It is actually safe, since the case when the input and output are the same
  register, having a potential of a reg-stack overflow for other insns,
  is just a no-op move here that is removed at all in reg-stack2.c.  */

(define_insn "_dup"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (match_operand:SI 1 "ABCreg_operand" "a"))]
  ""
  "dup")

(define_insn "_rev"
  [(set (match_operand:SI 0 "ABCreg_operand" "+a")
        (match_operand:SI 1 "ABCreg_operand" "+b"))
   (set (match_dup 1)
        (match_dup 0))]
  ""
  "rev")

/* This insn is only generated by the reg-stack converter. */

(define_insn "_pop"
  [(unspec [(match_operand:SI 0 "ABCreg_operand" "a")] 0)]
  "TARGET_HAVE_POP"
  "pop"
  [(set (attr "popped_inputs") (const_int 1))])

/* Unlike the hardware ldlp, this pattern takes an arbitrary offset
   and handles it with an additional adc, if needed.  */

(define_insn "_ldlp"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a,a")
	(plus:SI (match_operand:SI 2 "Wreg_operand" "")
                 (match_operand:SI 1 "const_int_operand" "I,?n")))]
  ""
  "@
   ldlp %q1
   ldlp %q1\;adc %r1")

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (match_operand:SI 1 "Wreg_operand" ""))]
  ""
  "ldlp 0")

/* `ajw' should come ahead of `adc'. */

(define_insn "_ajw"
  [(set (match_operand:SI 0 "Wreg_operand" "")
        (match_operand:SI 1 "local_operand_address" ""))]
  ""
  "ajw %w1")

(define_insn "_gajw"
  [(set (match_operand:SI 0 "Wreg_operand" "")
        (match_operand:SI 1 "ABCreg_operand" "a"))
   (set (match_dup 1)
        (match_dup 0))]
  ""
  "gajw")

(define_insn "_ldnl"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (match_operand:SI 1 "nonlocal_plus_operand" "U"))]
  ""
  "ldnl %w1"
  [(set (attr "popped_inputs") (const_int 2))])

(define_insn "_stnl"
  [(set (match_operand:SI 0 "nonlocal_plus_operand" "=U")
        (match_operand:SI 1 "ABCreg_operand" "b"))]
  ""
  "stnl %w0"
  [(set (attr "popped_inputs") (const_int 3))])

(define_insn "_ldnlp"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (plus:SI (match_operand:SI 1 "ABCreg_operand" "0")
                 (match_operand:SI 2 "word_offset_operand" "")))]
  ""
  "ldnlp %w2")

/* ldnlp 0 is a no-op -- omitted */


(define_insn "_ls"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (zero_extend:SI (match_operand:HI 1 "nonlocal_operand" "R")))]
  "TARGET_HAVE_SIXTEEN"
  "ls"
  [(set (attr "popped_inputs") (const_int 2))])                       

(define_insn "_ss"
  [(set (match_operand:HI 0 "nonlocal_operand" "=R")
        (match_operand:HI 1 "ABCreg_operand" "b"))]
  "TARGET_HAVE_SIXTEEN"
  "ss"
  [(set (attr "popped_inputs") (const_int 3))])


(define_insn "_lb"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (zero_extend:SI (match_operand:QI 1 "nonlocal_operand" "R")))]
  ""
  "lb"
  [(set (attr "popped_inputs") (const_int 2))])                       

(define_insn "_sb"
  [(set (match_operand:QI 0 "nonlocal_operand" "=R")
        (match_operand:QI 1 "ABCreg_operand" "b"))]
  ""
  "sb"
  [(set (attr "popped_inputs") (const_int 3))])


/* This strange pattern plays an important part of making it clear to
   expr.c that we CAN load a value from memory in QImode. We support
   QImode loads with (define_expand "movqi"), but the insn that
   actually does the loading (`lb') yields a SImode value, so that
   init_expr_once() fails to detect it.

   Without it we got restricted to SImode loads, which leads to extra
   pseudos and worse code.

   We prevent this pattern from matching ever except in the test
   mentioned by using `t800_init_once_completed' in the condition.  */

(define_insn ""
  [(set (reg:QI 0) (mem:QI (reg:SI 6)))]
  "! t800_init_once_completed"
  "*abort ();")



(define_insn "_fpdup"
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (match_operand:SF 1 "FABCreg_operand" "t"))]
  "TARGET_HAVE_FPU"
  "fpdup")

(define_insn ""
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (match_operand:DF 1 "FABCreg_operand" "t"))]
  "TARGET_HAVE_FPU"
  "fpdup")

(define_insn "_fprev"
  [(set (match_operand:SF 0 "FABCreg_operand" "+t")
        (match_operand:SF 1 "FABCreg_operand" "+u"))
   (set (match_dup 1)
        (match_dup 0))]
  "TARGET_HAVE_FPU"
  "fprev")

(define_insn ""
  [(set (match_operand:DF 0 "FABCreg_operand" "+t")
        (match_operand:DF 1 "FABCreg_operand" "+u"))
   (set (match_dup 1)
        (match_dup 0))]
  "TARGET_HAVE_FPU"
  "fprev")


(define_insn "_fpldzerosn"
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (match_operand:SF 1 "zero_operand" ""))]
  "TARGET_HAVE_FPU"
  "fpldzerosn")

(define_insn "_fpldzerodb"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (match_operand:DF 1 "zero_operand" ""))]
  "TARGET_HAVE_FPU"
  "fpldzerodb")


(define_insn "_fpldnlsn"
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (match_operand:SF 1 "nonlocal_operand" "R"))]
  "TARGET_HAVE_FPU"
  "fpldnlsn"
  [(set (attr "popped_inputs") (const_int 2))])

(define_insn "_fpldnldb"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (match_operand:DF 1 "nonlocal_operand" "R"))]
  "TARGET_HAVE_FPU"
  "fpldnldb"
  [(set (attr "popped_inputs") (const_int 2))])


(define_insn "_fpldnlsni"
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (mem:SF (plus:SI (mult:SI (match_operand:SI 1 "ABCreg_operand" "b")
                                  (const_int 4))
                         (match_operand:SI 2 "ABCreg_operand" "a"))))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpldnlsni"
  [(set (attr "popped_inputs") (const_int 6))])

(define_insn "_fpldnldbi"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (mem:DF (plus:SI (mult:SI (match_operand:SI 1 "ABCreg_operand" "b")
                                  (const_int 8))
                         (match_operand:SI 2 "ABCreg_operand" "a"))))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpldnldbi"
  [(set (attr "popped_inputs") (const_int 6))])


(define_insn "_fpstnlsn"
  [(set (match_operand:SF 0 "nonlocal_operand" "=R")
        (match_operand:SF 1 "FABCreg_operand" "t"))]
  "TARGET_HAVE_FPU"
  "fpstnlsn"
  [(set (attr "popped_inputs") (const_int 3))])

(define_insn "_fpstnldb"
  [(set (match_operand:DF 0 "nonlocal_operand" "=R")
        (match_operand:DF 1 "FABCreg_operand" "t"))]
  "TARGET_HAVE_FPU"
  "fpstnldb"
  [(set (attr "popped_inputs") (const_int 3))])


; Move from floating to integer register.  We have this redundant
; pattern for such moves, as it lets us to avoid reloading for such
; moves -- important because reloading is harmful in register function
; arguments preloading sequence.
;
(define_insn "sf_to_ABCreg"
  [(set (match_operand:SF 0 "ABCreg_operand" "=a,a,a")
        (match_operand:SF 1 "FABCreg_operand" "t,m,a"))
   (use (match_operand:SF 2 "local_operand" ""))]
  "TARGET_HAVE_FPU"
  "@
   ldlp %w2\;fpstnlsn\;ldl %w2
   ldl %w1
   OOPS -- this insn should have been deleted in reg-stack pass"
  [(set (attr "popped_inputs") (const_int 2))])

(define_insn "df_to_ABCreg"
  [(set (match_operand:DF 0 "ABCreg_operand" "=a,a,a")
        (match_operand:DF 1 "FABCreg_operand" "t,m,a"))
   (use (match_operand:DF 2 "local_operand" ""))]
  "TARGET_HAVE_FPU"
  "@
   ldlp %w2\;fpstnldb\;ldl %w2+1\;ldl %w2
   ldl %w1+1\;ldl %w1
   OOPS -- this insn should have been deleted in reg-stack pass"
  [(set (attr "popped_inputs") (const_int 2))])


;;------------------------------
;; reload_inM
;; reload_outM
;;------------------------------

/* We have to use secondary reloads when we are asked to reload a
   failed pseudo to/from an FP stack register, or from an integer
   reg-stack register in QImode.  These operations (fpldnlsn,
   fpldnldb, fpstnlsn, fpldnldb, sb) require a general register for
   memory address to reload to/from.  Input reloads in QImode are
   implemented with SImode load instruction (ldl) and therefore do not
   need an additional register.  Moreover, QImode pseudos get
   word-wide stack slot allocated, so we can always do QImode reloads
   with SImode insns which don't need scratch registers. */

;/* Sometimes, very rarely, we may need to do output reload from a
;   general register and into nonlocal memory.  The problem is that
;   default handling of this case in gen_reload() doesn't account for
;   the fact that stnl pops its address argument off the regstack, and
;   so a later insn that needs this address causes abort in reg-stack
;   converter.  So we define reload_outM to be able to copy the address
;   before stnl.
;
;   ??? Handling this for HImode is processor dependent and so pushed
;   aside for now.  */
;
;(define_expand "reload_outqi"
;  [(set (match_operand:QI 0 "nonlocal_operand" "=m")
;        (match_operand:QI 1 "ABCreg_operand" "r"))
;   (clobber (match_operand:SI 2 "" "=&r"))]
;  ""
;  "{
;    /* dup memory address to the scratch reg */
;    emit_insn (gen_rtx (SET, VOIDmode, operands[2], XEXP (operands[0],0)));
;    emit_insn (gen__sb (gen_rtx (MEM, QImode, operands[2]), operands[1]));
;    DONE;
;}")
;
;(define_expand "reload_outsi"
;  [(set (match_operand:SI 0 "nonlocal_operand" "=m")
;        (match_operand:SI 1 "ABCreg_operand" "r"))
;   (clobber (match_operand:SI 2 "" "=&r"))]
;  ""
;  "{
;    /* dup memory address to the scratch reg */
;    emit_insn (gen_rtx (SET, VOIDmode, operands[2], XEXP (operands[0],0)));
;    emit_insn (gen__stnl (gen_rtx (MEM, SImode, operands[2]), operands[1]));
;    DONE;
;}")


/* operand1 can be a stack slot
     (mem (Wreg)) or (mem (plus Wreg const_int))
   or memory constant
     (mem (symbol_ref))
   or even ABCreg

   We don't have a predicate handy to recognize all -- and probably we
   can do without a predicate, as we always want those patterns to be
   used when SECONDARY_RELOAD_CLASS says we need a secondary register.
   Same for reload_indf.  */

(define_expand "reload_insf"
  [(set (match_operand:SF 0 "FABCreg_operand" "=f")
        (match_operand:SF 1 "" "m"))
   (clobber (match_operand:SI 2 "" "=&r"))]
  "TARGET_HAVE_FPU"
  "{
    rtx base;

    /* If src is an ABCreg, we cannot move directly, so go
       through an intermediate stack slot. */

    if (t800_ABCreg_p (operands[1]))
      {
        rtx t800_temp_slot (enum machine_mode);
        rtx temp = t800_temp_slot (SFmode);
        emit_move_insn (temp, operands[1]);
        base = XEXP (temp, 0);
      }
    else
      {
        base = t800_get_reloaded_address (operands[1]);
      }
    emit_insn (gen_rtx (SET, VOIDmode, operands[2], base));
    emit_insn (gen__fpldnlsn (operands[0], gen_rtx (MEM, SFmode, operands[2])));
    DONE;
}")

(define_expand "reload_outsf"
  [(set (match_operand:SF 0 "" "=m")
        (match_operand:SF 1 "FABCreg_operand" "f"))
   (clobber (match_operand:SI 2 "" "=&r"))]
  "TARGET_HAVE_FPU"
  "{
    rtx temp = 0;
    rtx base;

    /* If dst is an ABCreg, we cannot move directly, so go through an
       intermediate stack slot.  We cannot use ABCreg_operand here, because it accepts pseudos*/

    if (t800_ABCreg_p (operands[0], SFmode))
      {
        rtx t800_temp_slot (enum machine_mode);
        temp = t800_temp_slot (SFmode);
        base = XEXP (temp, 0);
      }
    else
      {
        base = t800_get_reloaded_address (operands[0]);
      }

    emit_insn (gen_rtx (SET, VOIDmode, operands[2], base));
    emit_insn (gen__fpstnlsn (gen_rtx (MEM, SFmode, operands[2]), operands[1]));

    if (temp != 0)
      emit_move_insn (operands[0], temp);

    DONE;
}")

(define_expand "reload_indf"
  [(set (match_operand:DF 0 "FABCreg_operand" "=f")
        (match_operand:DF 1 "" "m"))
   (clobber (match_operand:SI 2 "" "=&r"))]
  "TARGET_HAVE_FPU"
  "{
    rtx base;

    /* If src is an ABCreg, we cannot move directly, so go
       through an intermediate stack slot. */

    if (t800_ABCreg_p (operands[1], DFmode))
      {
        rtx t800_temp_slot (enum machine_mode);
        rtx temp = t800_temp_slot (DFmode);
        emit_move_insn (temp, operands[1]);
        base = XEXP (temp, 0);
      }
    else
      {
        base = t800_get_reloaded_address (operands[1]);
      }
    emit_insn (gen_rtx (SET, VOIDmode, operands[2], base));
    emit_insn (gen__fpldnldb (operands[0], gen_rtx (MEM, DFmode, operands[2])));
    DONE;
}")

(define_expand "reload_outdf"
  [(set (match_operand:DF 0 "" "=m")
        (match_operand:DF 1 "FABCreg_operand" "f"))
   (clobber (match_operand:SI 2 "" "=&r"))]
  "TARGET_HAVE_FPU"
  "{
    rtx temp = 0;
    rtx base;

    /* If dst is an ABCreg, we cannot move directly, so go
       through an intermediate stack slot. */

    if (t800_ABCreg_p (operands[0], DFmode))
      {
        rtx t800_temp_slot (enum machine_mode);
        temp = t800_temp_slot (DFmode);
        base = XEXP (temp, 0);
      }
    else
      {
        base = t800_get_reloaded_address (operands[0]);
      }

    emit_insn (gen_rtx (SET, VOIDmode, operands[2], base));
    emit_insn (gen__fpstnldb (gen_rtx (MEM, DFmode, operands[2]), operands[1]));

    if (temp != 0)
      emit_move_insn (operands[0], temp);

    DONE;
}")


;;------------------------------
;; movstrictM
;;------------------------------
;; N/A


;;------------------------------
;; addM3
;;------------------------------

(define_expand "addsi3"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (plus:SI (match_operand:SI 1 "general_operand" "")
                 (match_operand:SI 2 "general_operand" "")))]
  ""
  "
	/* In dataseg-by-pointer model, if src is a SYMBOL_REF/v
	   (i.e. referring to data segment), it needs to be added the
	   dataseg start pointer first. */

	if (TARGET_DATASEG_BY_POINTER
            && ((GET_CODE (operands[2]) == SYMBOL_REF
                 && SYMBOL_REF_FLAG (operands[2]) == 1)
                || (GET_CODE (operands[2]) == CONST
                    && t800_dataseg_symrefs_mentioned_p (XEXP (operands[2], 0)))))
          {
	    rtx temp = gen_reg_rtx (Pmode);
	    rtx temp2 = gen_reg_rtx (Pmode);

	    emit_move_insn (temp, T800_DATASEG_START_RTX);
	    emit_insn (gen_rtx (SET, VOIDmode, temp2,
	                        gen_rtx (PLUS, Pmode, temp, operands[2])));
	       /* will match ldnlp or adc */
            operands[2] = temp2;
          }

	if (GET_CODE (operands[2]) == CONST_INT)
          {
            /* This is going to be either adc or ldlp; operands[1] should
               be ABCreg or Wreg respectively.

               _ldlp pattern accepts arbitrary constants (not
               word_offset only), so we can play simple here.  */

            operands[1] = force_reg (SImode, operands[1]);
          }
        else
          {
            operands[1] = force_ABCreg (SImode, operands[1]);
	    if (HAVE__ldpi2 && ldpi_operand (operands[2], SImode))
              ;  /* ldpi2 */
            else if (word_offset_operand (operands[2], SImode))
              ;  /* ldnlp */
            else
              operands[2] = force_ABCreg (SImode, operands[2]);
          }
")
/* to match _adc/_ldlp/ldnlp/_ldpi2/_add */


(define_insn "_adc"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (plus:SI (match_operand:SI 1 "ABCreg_operand" "0")
                 (match_operand:SI 2 "adc_operand" "")))]
  ""
  "adc %2")


/* Use `add' rather than `sum' since it is shorter (opcode #05 vs. #52).
   We couldn't keep error flag from being set occasionally anyway,
   since we want to use `adc', which does checking...  */

(define_insn "_add"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (plus:SI (match_operand:SI 1 "ABCreg_operand" "%b")
                 (match_operand:SI 2 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "add"
  [(set (attr "popped_inputs") (const_int 6))])


/* wsub, wsubdb, (if available) ssub */

(define_insn "_wsub"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (plus:SI (mult:SI (match_operand:SI 2 "ABCreg_operand" "b")
                          (match_operand:SI 3 "wsub_scale_operand" ""))
                 (match_operand:SI 1 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "*return
    INTVAL (operands[3]) == UNITS_PER_WORD    ? \"wsub\"  :
    INTVAL (operands[3]) == UNITS_PER_WORD*2  ? \"wsubdb\":
    TARGET_HAVE_SIXTEEN
      && INTVAL (operands[3]) == UNITS_PER_WORD/2  ? \"ssub\":
    (char *) abort();"
  [(set (attr "popped_inputs") (const_int 6))])


/* expand_binop tries to commute input operands to make the first one a
   register, so we don't need to expect nonlocal_operand at operands[1].  */

(define_expand "addsf3"
  [(set (match_operand:SF 0 "FABCreg_operand" "")
        (plus:SF (match_operand:SF 1 "FABCreg_operand" "")
                 (match_operand:SF 2 "FABCreg_or_nonlocal_operand" "")))]
  "TARGET_HAVE_FPU"
  "")

(define_insn ""
  [(set (match_operand:SF 0 "FABCreg_operand" "=t,t")
        (plus:SF (match_operand:SF 1 "FABCreg_operand" "%u,t")
                 (match_operand:SF 2 "FABCreg_or_nonlocal_operand" "t,R")))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "@
   fpadd
   fpldnladdsn"
  [(set (attr "popped_inputs") (const_int 6))])

(define_expand "adddf3"
  [(set (match_operand:DF 0 "FABCreg_operand" "")
        (plus:DF (match_operand:DF 1 "FABCreg_operand" "")
                 (match_operand:DF 2 "FABCreg_or_nonlocal_operand" "")))]
  "TARGET_HAVE_FPU"
  "")

(define_insn ""
  [(set (match_operand:DF 0 "FABCreg_operand" "=t,t")
        (plus:DF (match_operand:DF 1 "FABCreg_operand" "%u,t")
                 (match_operand:DF 2 "FABCreg_or_nonlocal_operand" "t,R")))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "@
   fpadd
   fpldnladddb"
  [(set (attr "popped_inputs") (const_int 6))])


;;------------------------------
;; subM3
;;------------------------------

/* `diff' and `sub' are both short, and both take 1 cycle. */

(define_expand "subsi3"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (minus:SI (match_operand:SI 1 "ABCreg_operand" "")
                  (match_operand:SI 2 "ABCreg_operand" "")))]
  ""
  "")

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (minus:SI (match_operand:SI 1 "ABCreg_operand" "b")
                  (match_operand:SI 2 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "diff"
  [(set (attr "popped_inputs") (const_int 6))])


(define_expand "subsf3"
  [(set (match_operand:SF 0 "FABCreg_operand" "")
        (minus:SF (match_operand:SF 1 "FABCreg_operand" "")
                  (match_operand:SF 2 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "")

(define_insn ""
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (minus:SF (match_operand:SF 1 "FABCreg_operand" "u")
                  (match_operand:SF 2 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpsub"
  [(set (attr "popped_inputs") (const_int 6))])

(define_expand "subdf3"
  [(set (match_operand:DF 0 "FABCreg_operand" "")
        (minus:DF (match_operand:DF 1 "FABCreg_operand" "")
                  (match_operand:DF 2 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "")

(define_insn ""
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (minus:DF (match_operand:DF 1 "FABCreg_operand" "u")
                  (match_operand:DF 2 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpsub"
  [(set (attr "popped_inputs") (const_int 6))])


;;------------------------------
;; mulM3
;;------------------------------

(define_expand "mulsi3"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (mult:SI (match_operand:SI 1 "ABCreg_operand" "")
                  (match_operand:SI 2 "nonmemory_operand" "")))]
  ""
  "{
    if (GET_CODE (operands[2]) == CONST_INT
        && INTVAL (operands[2]) == UNITS_PER_WORD)
      {
        emit_insn (gen__bcnt (operands[0],operands[1]));
        DONE;
      }
    else if (! ABCreg_operand (operands[2], VOIDmode))
      operands[2] = force_reg (SImode, operands[2]);
    /* to match _prod */
}")

(define_insn "_prod"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (mult:SI (match_operand:SI 1 "ABCreg_operand" "%b")
                  (match_operand:SI 2 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "prod"
  [(set (attr "popped_inputs") (const_int 6))])

(define_insn "_bcnt"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (mult:SI (match_operand:SI 1 "ABCreg_operand" "0")
                 (const_int 4)))]
  ""
  "bcnt")


(define_expand "mulsf3"
  [(set (match_operand:SF 0 "FABCreg_operand" "")
        (mult:SF (match_operand:SF 1 "FABCreg_operand" "")
                 (match_operand:SF 2 "whatever_operand" "")))]
  "TARGET_HAVE_FPU"
  "{
  if (fp_specval_operand (operands[2], SFmode))
    {
      emit_insn (gen__fpmul_by_specval (operands[0], operands[1], operands[2]));
      DONE;
    }
  if (! FABCreg_operand (operands[2], SFmode))
    operands[2] = copy_to_reg (operands[2]);

  /* to match _fpmul_fpldnlmulsn */
}")

(define_expand "muldf3"
  [(set (match_operand:DF 0 "FABCreg_operand" "")
        (mult:DF (match_operand:DF 1 "FABCreg_operand" "")
                 (match_operand:DF 2 "whatever_operand" "")))]
  "TARGET_HAVE_FPU"
  "{
  if (fp_specval_operand (operands[2], DFmode))
    {
      emit_insn (gen__fpmul_by_specval_df (operands[0], operands[1],
                                           operands[2]));
      DONE;
    }
  if (! FABCreg_operand (operands[2], DFmode))
    operands[2] = copy_to_reg (operands[2]);

  /* to match _fpmul_fpldnlmuldb */
}")

(define_insn "_fpmul_fpldnlmulsn"
  [(set (match_operand:SF 0 "FABCreg_operand" "=t,t")
        (mult:SF (match_operand:SF 1 "FABCreg_operand" "%u,t")
                 (match_operand:SF 2 "FABCreg_or_nonlocal_operand" "t,R")))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "@
   fpmul
   fpldnlmulsn"
  [(set (attr "popped_inputs") (const_int 6))])

(define_insn "_fpmul_fpldnlmuldb"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t,t")
        (mult:DF (match_operand:DF 1 "FABCreg_operand" "%u,t")
                 (match_operand:DF 2 "FABCreg_or_nonlocal_operand" "t,R")))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "@
   fpmul
   fpldnlmuldb"
  [(set (attr "popped_inputs") (const_int 6))])

(define_insn "_fpmul_by_specval"
  [(set (match_operand:SF 0 "FABCreg_operand" "=t,t")
        (mult:SF (match_operand:SF 1 "FABCreg_operand" "t,t")
                 (match_operand:SF 2 "fp_specval_operand" "G,H")))
   (clobber (match_scratch:SI 3 "=&r,&r"))]
  "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
  "@
   fpumulby2
   fpuexpinc32"
  [(set (attr "popped_inputs") (const_int 2))])

(define_insn ""
  [(set (match_operand:SF 0 "FABCreg_operand" "=t,t")
        (mult:SF (match_operand:SF 1 "FABCreg_operand" "t,t")
                 (match_operand:SF 2 "fp_specval_operand" "G,H")))]
  "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
  "@
   fpmulby2
   fpexpinc32"
  [(set (attr "popped_inputs") (const_int 2))])

(define_insn "_fpmul_by_specval_df"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t,t")
        (mult:DF (match_operand:DF 1 "FABCreg_operand" "t,t")
                 (match_operand:DF 2 "fp_specval_operand" "G,H")))
   (clobber (match_scratch:SI 3 "=&r,&r"))]
  "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
  "@
   fpumulby2
   fpuexpinc32"
  [(set (attr "popped_inputs") (const_int 2))])

(define_insn ""
  [(set (match_operand:DF 0 "FABCreg_operand" "=t,t")
        (mult:DF (match_operand:DF 1 "FABCreg_operand" "t,t")
                 (match_operand:DF 2 "fp_specval_operand" "G,H")))]
  "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
  "@
   fpmulby2
   fpexpinc32"
  [(set (attr "popped_inputs") (const_int 2))])

;;------------------------------
;; divM3
;;------------------------------

(define_expand "divsi3"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (div:SI (match_operand:SI 1 "ABCreg_operand" "")
                (match_operand:SI 2 "ABCreg_operand" "")))]
  ""
  "")

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (div:SI (match_operand:SI 1 "ABCreg_operand" "b")
                (match_operand:SI 2 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "div"
  [(set (attr "popped_inputs") (const_int 6))])


(define_expand "divsf3"
  [(set (match_operand:SF 0 "FABCreg_operand" "")
        (div:SF (match_operand:SF 1 "FABCreg_operand" "")
                 (match_operand:SF 2 "whatever_operand" "")))]
  "TARGET_HAVE_FPU"
  "{
  if (fp_specval_operand (operands[2], SFmode))
    {
      emit_insn (gen__fpdiv_by_specval (operands[0], operands[1], operands[2]));
      DONE;
    }
  if (! FABCreg_operand (operands[2], SFmode))
    operands[2] = copy_to_reg (operands[2]);

  /* to match _fpdiv */
}")

(define_insn "_fpdiv"
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (div:SF (match_operand:SF 1 "FABCreg_operand" "u")
                 (match_operand:SF 2 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpdiv"
  [(set (attr "popped_inputs") (const_int 6))])

(define_insn "_fpdiv_by_specval"
  [(set (match_operand:SF 0 "FABCreg_operand" "=t,t")
        (div:SF (match_operand:SF 1 "FABCreg_operand" "t,t")
                (match_operand:SF 2 "fp_specval_operand" "G,H")))
   (clobber (match_scratch:SI 3 "=&r,&r"))]
  "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
  "@
   fpudivby2
   fpuexpdec32"
  [(set (attr "popped_inputs") (const_int 2))])

(define_insn ""
  [(set (match_operand:SF 0 "FABCreg_operand" "=t,t")
        (div:SF (match_operand:SF 1 "FABCreg_operand" "t,t")
                (match_operand:SF 2 "fp_specval_operand" "G,H")))]
  "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
  "@
   fpdivby2
   fpexpdec32"
  [(set (attr "popped_inputs") (const_int 2))])


(define_expand "divdf3"
  [(set (match_operand:DF 0 "FABCreg_operand" "")
        (div:DF (match_operand:DF 1 "FABCreg_operand" "")
                 (match_operand:DF 2 "whatever_operand" "")))]
  "TARGET_HAVE_FPU"
  "{
  if (fp_specval_operand (operands[2], DFmode))
    {
      emit_insn (gen__fpdiv_by_specval_df (operands[0], operands[1],
                                           operands[2]));
      DONE;
    }
  if (! FABCreg_operand (operands[2], DFmode))
    operands[2] = copy_to_reg (operands[2]);

  /* to match _fpdiv_df */
}")

(define_insn "_fpdiv_df"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (div:DF (match_operand:DF 1 "FABCreg_operand" "u")
                 (match_operand:DF 2 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpdiv"
  [(set (attr "popped_inputs") (const_int 6))])

(define_insn "_fpdiv_by_specval_df"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t,t")
        (div:DF (match_operand:DF 1 "FABCreg_operand" "t,t")
                (match_operand:DF 2 "fp_specval_operand" "G,H")))
   (clobber (match_scratch:SI 3 "=&r,&r"))]
  "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
  "@
   fpudivby2
   fpuexpdec32"
  [(set (attr "popped_inputs") (const_int 2))])

(define_insn ""
  [(set (match_operand:DF 0 "FABCreg_operand" "=t,t")
        (div:DF (match_operand:DF 1 "FABCreg_operand" "t,t")
                (match_operand:DF 2 "fp_specval_operand" "G,H")))]
  "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
  "@
   fpdivby2
   fpexpdec32"
  [(set (attr "popped_inputs") (const_int 2))])

;;------------------------------
;; udivM3
;;------------------------------
;; udivmodM4 is used instead


;;------------------------------
;; modM3
;;------------------------------

(define_expand "modsi3"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (mod:SI (match_operand:SI 1 "ABCreg_operand" "")
                (match_operand:SI 2 "ABCreg_operand" "")))]
  ""
  "")

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (mod:SI (match_operand:SI 1 "ABCreg_operand" "b")
                (match_operand:SI 2 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "rem"
  [(set (attr "popped_inputs") (const_int 6))])


(define_expand "modsf3"
  [(set (match_operand:SF 0 "FABCreg_operand" "")
        (mod:SF (match_operand:SF 1 "FABCreg_operand" "")
                (match_operand:SF 2 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "")

(define_insn ""
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (mod:SF (match_operand:SF 1 "FABCreg_operand" "u")
                (match_operand:SF 2 "FABCreg_operand" "t")))
   (clobber (match_scratch:SI 3 "=&r"))
   (clobber (match_scratch:SI 4 "=&r"))
   (clobber (match_scratch:SI 5 "=&r"))
   (clobber (match_scratch:SF 6 "=&f"))]
  "TARGET_HAVE_FPU
   && TARGET_HAVE_FPENTRY
   && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpremfirst
	eqc 0
	cj LF%=2
LF%=1
	fpremstep
	cj LF%=1
LF%=2"
  [(set (attr "popped_inputs") (const_int 6))])


(define_expand "moddf3"
  [(set (match_operand:DF 0 "FABCreg_operand" "")
        (mod:DF (match_operand:DF 1 "FABCreg_operand" "")
                (match_operand:DF 2 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "")

(define_insn ""
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (mod:DF (match_operand:DF 1 "FABCreg_operand" "u")
                (match_operand:DF 2 "FABCreg_operand" "t")))
   (clobber (match_scratch:SI 3 "=&r"))
   (clobber (match_scratch:SI 4 "=&r"))
   (clobber (match_scratch:SI 5 "=&r"))
   (clobber (match_scratch:SF 6 "=&f"))]
  "TARGET_HAVE_FPU
   && TARGET_HAVE_FPENTRY
   && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpremfirst
	eqc 0
	cj LF%=2
LF%=1
	fpremstep
	cj LF%=1
LF%=2"
  [(set (attr "popped_inputs") (const_int 6))])

(define_insn ""
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (mod:SF (match_operand:SF 1 "FABCreg_operand" "u")
                (match_operand:SF 2 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU
   && ! TARGET_HAVE_FPENTRY
   && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fprem"
  [(set (attr "popped_inputs") (const_int 6))])

(define_insn ""
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (mod:DF (match_operand:DF 1 "FABCreg_operand" "u")
                (match_operand:DF 2 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU
   && ! TARGET_HAVE_FPENTRY
   && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fprem"
  [(set (attr "popped_inputs") (const_int 6))])


;;------------------------------
;; umodM3
;;------------------------------
;; udivmodM4 is used instead


;;------------------------------
;; sminM3
;; smaxM3
;; uminM3
;; umaxM3
;;------------------------------
;; N/A

;;------------------------------
;; andM3
;;------------------------------

(define_expand "andsi3"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (and:SI (match_operand:SI 1 "ABCreg_operand" "")
                (match_operand:SI 2 "ABCreg_operand" "")))]
  ""
  "")

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (and:SI (match_operand:SI 1 "ABCreg_operand" "%b")
                (match_operand:SI 2 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "and"
  [(set (attr "popped_inputs") (const_int 6))])


;;------------------------------
;; iorM3
;;------------------------------

(define_expand "iorsi3"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (ior:SI (match_operand:SI 1 "ABCreg_operand" "")
                (match_operand:SI 2 "ABCreg_operand" "")))]
  ""
  "")

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (ior:SI (match_operand:SI 1 "ABCreg_operand" "%b")
                (match_operand:SI 2 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "or"
  [(set (attr "popped_inputs") (const_int 6))])


;;------------------------------
;; xorM3
;;------------------------------

(define_expand "xorsi3"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (xor:SI (match_operand:SI 1 "ABCreg_operand" "")
                (match_operand:SI 2 "ABCreg_operand" "")))]
  ""
  "")

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (xor:SI (match_operand:SI 1 "ABCreg_operand" "%b")
                (match_operand:SI 2 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "xor"
  [(set (attr "popped_inputs") (const_int 6))])


;;------------------------------
;; mulhisi3
;; mulqihi3
;;------------------------------
;; N/A


;;------------------------------
;; mulsidi3
;;------------------------------

(define_expand "mulsidi3"
  [(set (match_operand:DI 0 "ABCreg_operand" "")
        (plus:DI
          (mult:DI (sign_extend:DI (match_operand:SI 1 "ABCreg_operand" ""))
                   (sign_extend:DI (match_operand:SI 2 "ABCreg_operand" "")))
          (sign_extend:DI (match_dup 3))))]
  "TARGET_HAVE_SLMUL"
  "{operands[3] = force_reg (SImode, CONST0_RTX (SImode));
   /* to match _slmul */
}")

(define_insn "_slmul"
  [(set (match_operand:DI 0 "ABCreg_operand" "=a")
        (plus:DI
          (mult:DI (sign_extend:DI (match_operand:SI 1 "ABCreg_operand" "%b"))
                   (sign_extend:DI (match_operand:SI 2 "ABCreg_operand" "a")))
          (sign_extend:DI (match_operand:SI 3 "ABCreg_operand" "c"))))]
  "TARGET_HAVE_SLMUL
   && T800_DISTINCT_REGS (operands[1], operands[2])
   && T800_DISTINCT_REGS (operands[2], operands[3])
   && T800_DISTINCT_REGS (operands[1], operands[3])"
  "slmul"
  [(set (attr "popped_inputs") (const_int 14))])

/* sulmul is not directly usable for code generation.  Yeah, tell GCC
   about it and see if it will manage to use it... */

(define_insn "_sulmul"
  [(set (match_operand:DI 0 "ABCreg_operand" "=a")
        (plus:DI
          (mult:DI (zero_extend:DI (match_operand:SI 1 "ABCreg_operand" "b"))
                   (sign_extend:DI (match_operand:SI 2 "ABCreg_operand" "a")))
          (sign_extend:DI (match_operand:SI 3 "ABCreg_operand" "c"))))]
  "TARGET_HAVE_SLMUL
   && T800_DISTINCT_REGS (operands[1], operands[2])
   && T800_DISTINCT_REGS (operands[2], operands[3])
   && T800_DISTINCT_REGS (operands[1], operands[3])"
  "sulmul"
  [(set (attr "popped_inputs") (const_int 14))])


;;------------------------------
;; umulhisi3
;; umulqihi3
;;------------------------------
;; N/A

;;------------------------------
;; umulsidi3
;;------------------------------

(define_expand "umulsidi3"
  [(set (match_operand:DI 0 "ABCreg_operand" "")
        (plus:DI
          (mult:DI (zero_extend:DI (match_operand:SI 1 "ABCreg_operand" ""))
                   (zero_extend:DI (match_operand:SI 2 "ABCreg_operand" "")))
          (zero_extend:DI (match_dup 3))))]
  ""
  "{operands[3] = force_reg (SImode, CONST0_RTX (SImode));
   /* to match _lmul */
}")

(define_insn "_lmul"
  [(set (match_operand:DI 0 "ABCreg_operand" "=a")
        (plus:DI
          (mult:DI (zero_extend:DI (match_operand:SI 1 "ABCreg_operand" "%b"))
                   (zero_extend:DI (match_operand:SI 2 "ABCreg_operand" "a")))
          (zero_extend:DI (match_operand:SI 3 "ABCreg_operand" "c"))))]
  "T800_DISTINCT_REGS (operands[1], operands[2])
   && T800_DISTINCT_REGS (operands[2], operands[3])
   && T800_DISTINCT_REGS (operands[1], operands[3])"
  "lmul"
  [(set (attr "popped_inputs") (const_int 14))])


;;------------------------------
;; divmodM4
;;------------------------------

/* This is available only for divsor == UNITS_PER_WORD. */

(define_expand "divmodsi4"
  [(parallel
    [(set (match_operand:SI 0 "ABCreg_operand" "")
          (div:SI (match_operand:SI 1 "ABCreg_operand" "")
                  (match_operand:SI 2 "nonmemory_operand" "")))
     (set (match_operand:SI 3 "ABCreg_operand" "")
          (mod:SI (match_dup 1)
                  (match_dup 2)))])]
  ""
  "{
  if (GET_CODE (operands[3]) != CONST_INT
      || INTVAL (operands[3]) != UNITS_PER_WORD)
    FAIL;
  /* to match _wcnt */
}")

(define_insn "_wcnt"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (div:SI (match_operand:SI 1 "ABCreg_operand" "0")
                (const_int 4)))
   (set (match_operand:SI 2 "ABCreg_operand" "=b")
        (mod:SI (match_dup 1)
                (const_int 4)))]
  ""
  "wcnt")


;;------------------------------
;; udivmodM4
;;------------------------------

(define_expand "udivmodsi4"
  [(parallel
    [(set (match_operand:SI 0 "ABCreg_operand" "")
          (truncate:SI
            (udiv:DI (match_operand:SI 1 "ABCreg_operand" "")
                     (zero_extend:DI
                       (match_operand:SI 2 "ABCreg_operand" "")))))
    (set (match_operand:SI 3 "ABCreg_operand" "")
         (truncate:SI (umod:DI (match_dup 1)
                               (zero_extend:DI (match_dup 2)))))])]
  ""
  "{
  operands[1] = convert_to_mode (DImode, operands[1], 1 /*unsigned_p*/);
  /* to match _ldiv */
}")

(define_insn "_ldiv"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (truncate:SI (udiv:DI (match_operand:DI 1 "ABCreg_operand" "b")
                              (zero_extend:DI
                                (match_operand:SI 2 "ABCreg_operand" "a")))))
   (set (match_operand:SI 3 "ABCreg_operand" "=b")
        (truncate:SI (umod:DI (match_dup 1)
                     (zero_extend:DI (match_dup 2)))))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "ldiv"
  [(set (attr "popped_inputs") (const_int 6))])


;;------------------------------
;; ashlM3
;;------------------------------
(define_expand "ashlsi3"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (ashift:SI (match_operand:SI 1 "ABCreg_operand" "")
                   (match_operand:SI 2 "ABCreg_operand" "")))]
  ""
  "")

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (ashift:SI (match_operand:SI 1 "ABCreg_operand" "b")
                   (match_operand:SI 2 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "shl"
  [(set (attr "popped_inputs") (const_int 6))])

(define_expand "ashldi3"
  [(set (match_operand:DI 0 "ABCreg_operand" "")
        (ashift:DI (match_operand:DI 1 "ABCreg_operand" "")
                   (match_operand:SI 2 "ABCreg_operand" "")))]
  ""
  "")

(define_insn ""
  [(set (match_operand:DI 0 "ABCreg_operand" "=a")
        (ashift:DI (match_operand:DI 1 "ABCreg_operand" "b")
                   (match_operand:SI 2 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "lshl"
  [(set (attr "popped_inputs") (const_int 6))])


;;------------------------------
;; ashrM3
;;------------------------------

/* We use whatever_operand here to obtain the right operand evaluation
   order; this tends to save us some reg-stack shuffling aferwards.  */

(define_expand "ashrsi3"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (ashiftrt:SI (match_operand:SI 1 "whatever_operand" "")
                     (match_operand:SI 2 "whatever_operand" "")))]
  ""
  "{
     rtx tmp = gen_reg_rtx(DImode);

     operands[1] = convert_to_mode (DImode, operands[1], 0/*!unsigned_p*/);

     if (! ABCreg_operand (operands[1], DImode))
       operands[1] = force_reg (DImode, operands[1]);

     if (! ABCreg_operand (operands[2], SImode))
       operands[2] = force_reg (SImode, operands[2]);

     /* Tried to avoid the final move insn by getting the output of
        _lshr into (SUBREG:DI operands[0]). This fails, since operands[0]
        is a SImode pseudo and gets a single hard register only; it seems
        illegal to assign to it in DImode (?).  */

     emit_insn (gen_ashrdi3 (tmp, operands[1], operands[2]));
     emit_move_insn (operands[0], gen_rtx (SUBREG, SImode, tmp, 0));
     DONE;
}")

(define_expand "ashrdi3"
  [(set (match_operand:DI 0 "ABCreg_operand" "")
        (lshiftrt:DI (match_operand:DI 1 "ABCreg_operand" "")
                     (match_operand:SI 2 "ABCreg_operand" "")))]
  ""
  "")

(define_insn ""
  [(set (match_operand:DI 0 "ABCreg_operand" "=a")
        (lshiftrt:DI (match_operand:DI 1 "ABCreg_operand" "b")
                     (match_operand:SI 2 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "lshr"
  [(set (attr "popped_inputs") (const_int 6))])

;;------------------------------
;; lshlM3
;;------------------------------
;; This is the same as ashlM3.  Needs not be defined if negative shift
;; count is not allowed.

;;------------------------------
;; lshrM3
;;------------------------------

(define_expand "lshrsi3"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (lshiftrt:SI (match_operand:SI 1 "ABCreg_operand" "")
                     (match_operand:SI 2 "ABCreg_operand" "")))]
  ""
  "")

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (lshiftrt:SI (match_operand:SI 1 "ABCreg_operand" "b")
                     (match_operand:SI 2 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "shr"
  [(set (attr "popped_inputs") (const_int 6))])


;;------------------------------
;; rotlM3
;; rotrM3
;;------------------------------
(define_expand "rotlsi3"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (rotate:SI (match_operand:SI 1 "whatever_operand" "")
                   (match_operand:SI 2 "whatever_operand" "")))]
  ""
  "{
     rtx tmp = gen_reg_rtx(DImode);

     /* Evaluate operands in the desired order */
     emit_move_insn (gen_rtx (SUBREG, SImode, tmp, 1), operands[1]);
     emit_move_insn (gen_rtx (SUBREG, SImode, tmp, 0), GEN_INT (0));

     if (! ABCreg_operand (operands[2], SImode))
       operands[2] = force_reg (SImode, operands[2]);

     emit_insn (gen_ashldi3 (tmp, tmp, operands[2]));
     emit_insn (gen_iorsi3 (operands[0], gen_rtx (SUBREG, SImode, tmp, 0),
                                         gen_rtx (SUBREG, SImode, tmp, 1)));
     DONE;
}")

(define_expand "rotrsi3"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (rotatert:SI (match_operand:SI 1 "whatever_operand" "")
                     (match_operand:SI 2 "whatever_operand" "")))]
  ""
  "{
     rtx tmp = gen_reg_rtx(DImode);

     operands[1] = convert_to_mode (DImode, operands[1], 1/*unsigned_p*/);

     if (! ABCreg_operand (operands[1], DImode))
       operands[1] = force_reg (DImode, operands[1]);
     if (! ABCreg_operand (operands[2], SImode))
       operands[2] = force_reg (SImode, operands[2]);

     emit_insn (gen_ashrdi3 (tmp, operands[1], operands[2]));
     emit_insn (gen_iorsi3 (operands[0], gen_rtx (SUBREG, SImode, tmp, 0),
                                         gen_rtx (SUBREG, SImode, tmp, 1)));
     DONE;
}")


;;------------------------------
;; negM2
;;------------------------------

(define_expand "negsi2"
  [(set (match_dup 2)
        (not:SI (match_operand:SI 1 "ABCreg_operand" "")))
   (set (match_operand:SI 0 "ABCreg_operand" "")
        (plus:SI (match_dup 2)
                 (const_int 1)))]
  ""
  "operands[2] = gen_reg_rtx (SImode);
   /* to match `not; adc 1' */
")

/* Floating point negation.  It is now implemented as (0 - x), and so
   requires the operand to be in an fp register.

   ??? We could also do it with XOR, if the operand is in an integer
   reg or in memory.  */

(define_expand "negsf2"
  [(set (match_dup 2)
        (match_dup 3))
   (set (match_operand:SF 0 "FABCreg_operand" "")
        (minus:SF (match_dup 2)
                (match_operand:SF 1 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "operands[2] = gen_reg_rtx (SFmode);
   operands[3] = CONST0_RTX (SFmode);
   /* to match `fpldzerosn; fpsub' */
")

(define_expand "negdf2"
  [(set (match_dup 2)
        (match_dup 3))
   (set (match_operand:DF 0 "FABCreg_operand" "")
        (minus:DF (match_dup 2)
                (match_operand:DF 1 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "operands[2] = gen_reg_rtx (DFmode);
   operands[3] = CONST0_RTX (DFmode);
   /* to match `fpldzerosn; fpsub' */
")


;;------------------------------
;; absM2
;;------------------------------

(define_insn "abssf3"
  [(set (match_operand:SF 0 "FABCreg_operand" "")
        (abs:SF (match_operand:SF 1 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "")

(define_insn "absdf3"
  [(set (match_operand:DF 0 "FABCreg_operand" "")
        (abs:DF (match_operand:DF 1 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "")

(define_insn ""
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (abs:SF (match_operand:SF 1 "FABCreg_operand" "0")))
   (clobber (match_scratch:SI 2 "=&r"))]
  "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
  "fpuabs")

(define_insn ""
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (abs:SF (match_operand:SF 1 "FABCreg_operand" "0")))]
  "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
  "fpabs")

(define_insn ""
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (abs:DF (match_operand:DF 1 "FABCreg_operand" "0")))
   (clobber (match_scratch:SI 2 "=&r"))]
  "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
  "fpuabs")

(define_insn ""
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (abs:DF (match_operand:DF 1 "FABCreg_operand" "0")))]
  "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
  "fpabs")


;;------------------------------
;; sqrtM2
;;------------------------------

(define_expand "sqrtsf3"
  [(set (match_operand:SF 0 "FABCreg_operand" "")
        (sqrt:SF (match_operand:SF 1 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "if (TARGET_HAVE_FPENTRY) {
     emit_insn (gen__fpusqrt_sequence_sf (operands[0], operands[1]));
     DONE;
   }
")

(define_expand "sqrtdf3"
  [(set (match_operand:DF 0 "FABCreg_operand" "")
        (sqrt:DF (match_operand:DF 1 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "if (TARGET_HAVE_FPENTRY) {
     emit_insn (gen__fpusqrt_sequence_df (operands[0], operands[1]));
     DONE;
   }
")

(define_insn "_fpusqrt_sequence_sf"
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (sqrt:SF (match_operand:SF 1 "FABCreg_operand" "0")))
   (clobber (match_scratch:SI 3 "=&r"))
   (clobber (match_scratch:SF 4 "=&f"))
   (clobber (match_scratch:SF 5 "=&f"))]
  "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
  "fpusqrtfirst\;fpusqrtstep\;fpusqrtstep\;fpusqrtlast")

(define_insn ""
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (sqrt:SF (match_operand:SF 1 "FABCreg_operand" "0")))]
  "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
  "fpsqrt")

(define_insn "_fpusqrt_sequence_df"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (sqrt:DF (match_operand:DF 1 "FABCreg_operand" "0")))
   (clobber (match_scratch:SI 3 "=&r"))
   (clobber (match_scratch:SF 4 "=&f"))
   (clobber (match_scratch:SF 5 "=&f"))]
  "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
  "fpusqrtfirst\;fpusqrtstep\;fpusqrtstep\;fpusqrtstep\;fpusqrtstep\;fpusqrtstep\;fpusqrtlast")

(define_insn ""
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (sqrt:DF (match_operand:DF 1 "FABCreg_operand" "0")))]
  "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
  "fpsqrt")


;;------------------------------
;; ffsM2
;;------------------------------

; bet this will never be used  :-)

(define_insn "ffssi2"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (ffs:SI (match_operand:DI 1 "ABCreg_operand" "a")))
   (clobber (match_scratch:SI 2 "=&r"))]
  ""
  "bitrevword\;rev\;bitrevword\;norm\;diff\;rev\;adc 1\;ldc 65\;rem"
  [(set (attr "popped_inputs") (const_int 2))])

	
;;------------------------------
;; one_cmplM2
;;------------------------------

(define_insn "one_cmplsi2"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (not:SI (match_operand:SI 1 "ABCreg_operand" "0")))]
  ""
  "not")

;;------------------------------
;; cmpM
;;------------------------------

/* For compare operations, we simply store the comparison operands and
   generate no insns.  The following bCC or sCC insn will output
   whatever is needed.  */

/* Compare in QImode can sometimes be better that convert to SImode
   plus compare in SImode.  For example, SImode unsigned comparisons
   are based on `ldiff', while in QImode a cheap `gt' is sufficient.
   Therefore we declare the QImode comparisons.  */

(define_expand "cmpqi"
  [(match_operand:QI 0 "general_operand" "")
   (match_operand:QI 1 "general_operand" "")]
  "TARGET_USE_cmpqi"
  "{
  t800_compare.op[0] = operands[0];
  t800_compare.op[1] = operands[1];
  t800_compare.fp = 0;
  DONE;
}")

(define_expand "cmphi"
  [(match_operand:HI 0 "general_operand" "")
   (match_operand:HI 1 "general_operand" "")]
  "TARGET_USE_cmpqi"
  "{
  t800_compare.op[0] = operands[0];
  t800_compare.op[1] = operands[1];
  t800_compare.fp = 0;
  DONE;
}")

(define_expand "cmpsi"
  [(match_operand:SI 0 "ABCreg_operand" "")
   (match_operand:SI 1 "nonmemory_operand" "")]
  ""
  "{
  t800_compare.op[0] = operands[0];
  t800_compare.op[1] = operands[1];
  t800_compare.fp = 0;
  DONE;
}")

(define_expand "cmpsf"
  [(match_operand:SF 0 "FABCreg_operand" "")
   (match_operand:SF 1 "FABCreg_operand" "")]
  "TARGET_HAVE_FPU"
  "{
  t800_compare.op[0] = operands[0];
  t800_compare.op[1] = operands[1];
  t800_compare.fp = 1;
  DONE;
}")

(define_expand "cmpdf"
  [(match_operand:DF 0 "FABCreg_operand" "")
   (match_operand:DF 1 "FABCreg_operand" "")]
  "TARGET_HAVE_FPU"
  "{
  t800_compare.op[0] = operands[0];
  t800_compare.op[1] = operands[1];
  t800_compare.fp = 1;
  DONE;
}")

;;------------------------------
;; tstM
;;------------------------------
;; Should not be defined as transputers do not have (cc0)

;;------------------------------
;; movstrM
;;------------------------------

(define_expand "movstrsi"
  [(set (match_operand:BLK 0 "general_operand" "")
        (match_operand:BLK 1 "general_operand" ""))
   (use (match_operand:SI 2 "general_operand" ""))
   (use (match_operand:SI 3 "" ""))]
  ""
  "{
    rtx src, dest, len;

    if (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)
      abort ();

    /* Don't use force_reg on addresses, because it wouldn't do
       anything with Wreg, while we need ABCreg */

    dest = XEXP (operands[0], 0);
    if (! ABCreg_operand (dest, VOIDmode))
	dest = copy_addr_to_reg (dest);

    src = XEXP (operands[1], 0);
    if (! ABCreg_operand (src, VOIDmode))
	src = copy_addr_to_reg (src);

    len = force_reg (SImode, operands[2]);

    emit_insn (gen__move (dest, src, len));
    DONE;
}")

(define_insn "_move"
  [(set (mem:BLK (match_operand:SI 0 "ABCreg_operand" "b"))
        (mem:BLK (match_operand:SI 1 "ABCreg_operand" "c")))
   (use (match_operand:SI 2 "ABCreg_operand" "a"))]
  ""
  "move"
  [(set (attr "popped_inputs") (const_int 7))])

;;------------------------------
;; cmpstrM
;;------------------------------
;; N/A

/* Conversions -----------------------------

Legend: 
    -   no conversion applies
    f   floatMN2
    fu  floatunsMN2
    x   fixMN2
    xu  fixunsMN2
    xt  fix_truncMN2
    xtu fixuns_truncMN2
    ft  ftruncM2
    t   truncMN
    e   extendMN
    z   zero-extendMN

All possible conversions:
        QI          SI          DI          SF          DF
QI      -           e,z         e,z         f           f
SI      t           -           e,z         f,fu        f,fu
DI      t           t           -           f,fu        f,fu
SF      x,xu,xt,xtu x,xu,xt,xtu x,xu,xt,xtu ft          e
DF      x,xu,xt,xtu x,xu,xt,xtu x,xu,xt,xtu t           ft

Available insns on transputer:
        QI          SI          DI          SF          DF
QI      -           e,(z)       -           -           -
SI      (t)         -           e,(z)       f,fu        f,fu
DI      -           (t)         -           (f)         (f)   
SF      -           x           (x)         ft          e
DF      -           x           (x)         t           ft

   e     (extendQISI):       xword
   e     (extendSIDI):       xdble
   t     (truncdfsf):        fpur64tor32
   e     (extendsfdf):       fpur32tor64
   ft    (ftrunc[sd]f):      fpint
   x     (fix[sd]fsi):       fpstnli32
   f     (floatsisf):        fpi32tor32
   f     (floatsidf):        fpi32tor64
   fu    (floatunssidf):     fpb32tor64
   (x)   (fix[sd]fdi):       <sequence>
   (f)   (floatdi[sd]f):     <sequence>
*/

;;------------------------------
;; floatMN2
;;------------------------------

/* Insns of this group on trabsputers are only able to take input from
   memory.  Therefore, when asked to take input from a register, we
   allocate a stack slot and copy the input register in there before
   the insn.  Thus, we have to have an expander for every insn of this
   group :-( */

(define_expand "floatsisf2"
  [(set (match_operand:SF 0 "FABCreg_operand" "")
        (float:SF (match_operand:SI 1 "general_operand" "")))]
  "TARGET_HAVE_FPU"
  "{
  rtx t800_temp_slot (enum machine_mode);
  rtx t800_force_nonlocal (rtx);
  
  if (! nonlocal_operand (operands[1], SImode))
    {
      if (GET_CODE (operands[1]) != MEM)
        {
          rtx temp = t800_temp_slot (SImode);
          emit_move_insn (temp, operands[1]);
          operands[1] = temp;
        }
      operands[1] = t800_force_nonlocal (operands[1]);
    }
  /* to match _fpi32tor32 */
}")

(define_insn "_fpi32tor32"
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (float:SF (match_operand:SI 1 "nonlocal_operand" "R")))]
  "TARGET_HAVE_FPU"
  "fpi32tor32"
  [(set (attr "popped_inputs") (const_int 2))])


(define_expand "floatsidf2"
  [(set (match_operand:DF 0 "FABCreg_operand" "")
        (float:DF (match_operand:SI 1 "general_operand" "")))]
  "TARGET_HAVE_FPU"
  "{
  rtx t800_temp_slot (enum machine_mode);
  rtx t800_force_nonlocal (rtx);
  
  if (! nonlocal_operand (operands[1], SImode))
    {
      if (GET_CODE (operands[1]) != MEM)
        {
          rtx temp = t800_temp_slot (SImode);
          emit_move_insn (temp, operands[1]);
          operands[1] = temp;
        }
      operands[1] = t800_force_nonlocal (operands[1]);
    }
  /* to match _fpi32tor64 */
}")

(define_insn "_fpi32tor64"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (float:DF (match_operand:SI 1 "nonlocal_operand" "R")))]
  "TARGET_HAVE_FPU"
  "fpi32tor64"
  [(set (attr "popped_inputs") (const_int 2))])


(define_expand "floatdisf2"
  [(parallel
    [(set (match_operand:SF 0 "FABCreg_operand" "")
          (float:SF (match_operand:DI 1 "general_operand" "")))
     (clobber (match_scratch:SI 2 ""))
     (clobber (match_scratch:SF 3 ""))])]
  "TARGET_HAVE_FPU"
  "{
  rtx t800_temp_slot (enum machine_mode);
  rtx t800_force_nonlocal (rtx);
  
  if (! nonlocal_operand (operands[1], DImode))
    {
      if (GET_CODE (operands[1]) != MEM)
        {
          rtx temp = t800_temp_slot (DImode);
          emit_move_insn (temp, operands[1]);
          operands[1] = temp;
        }
      operands[1] = t800_force_nonlocal (operands[1]);
    }
  /* to match _INT64_to_REAL32 */
}")

/* INT64 to REAL32 sequence in Round-to-Nearest mode */

(define_insn ""
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (float:SF (match_operand:DI 1 "nonlocal_operand" "R")))
   (clobber (match_scratch:SI 2 "=&r"))
   (clobber (match_scratch:SF 3 "=&f"))]
  "TARGET_HAVE_FPU"
  "* return TARGET_HAVE_FPENTRY ?
     \"dup\;fpb32tor64\;fpunoround\;ldnlp 1\;fpi32tor64\;fpuexpinc32\;fpunoround\;fpadd\" :
     \"dup\;fpb32tor64\;ldnlp 1\;fpi32tor64\;fpexpinc32\;fpadddbsn\";"
  [(set (attr "popped_inputs") (const_int 2))])

(define_expand "floatdidf2"
  [(parallel
    [(set (match_operand:DF 0 "FABCreg_operand" "")
          (float:DF (match_operand:DI 1 "general_operand" "")))
     (clobber (match_scratch:SI 2 ""))
     (clobber (match_scratch:SF 3 ""))])]
  "TARGET_HAVE_FPU"
  "{
  rtx t800_temp_slot (enum machine_mode);
  rtx t800_force_nonlocal (rtx);
  
  if (! nonlocal_operand (operands[1], DImode))
    {
      if (GET_CODE (operands[1]) != MEM)
        {
          rtx temp = t800_temp_slot (DImode);
          emit_move_insn (temp, operands[1]);
          operands[1] = temp;
        }
      operands[1] = t800_force_nonlocal (operands[1]);
    }
  /* to match _INT64_to_REAL64 */
}")


/* INT64 to REAL64 sequence in Round-to-Nearest mode */

(define_insn "_INT64_to_REAL64"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (float:DF (match_operand:DI 1 "nonlocal_operand" "R")))
   (clobber (match_scratch:SI 2 "=&r"))
   (clobber (match_scratch:SF 3 "=&f"))]
  "TARGET_HAVE_FPU"
  "* return TARGET_HAVE_FPENTRY ?
     \"dup\;fpb32tor64\;ldnlp 1\;fpi32tor64\;fpuexpinc32\;fpadd\" :
     \"dup\;fpb32tor64\;ldnlp 1\;fpi32tor64\;fpexpinc32\;fpadd\";"
  [(set (attr "popped_inputs") (const_int 2))])


;;------------------------------
;; floatunsMN2
;;------------------------------

(define_expand "floatunssidf2"
  [(set (match_operand:DF 0 "FABCreg_operand" "")
        (unsigned_float:DF (match_operand:SI 1 "general_operand" "")))]
  "TARGET_HAVE_FPU"
  "{
  rtx t800_temp_slot (enum machine_mode);
  rtx t800_force_nonlocal (rtx);
  
  if (! nonlocal_operand (operands[1], SImode))
    {
      if (GET_CODE (operands[1]) != MEM)
        {
          rtx temp = t800_temp_slot (SImode);
          emit_move_insn (temp, operands[1]);
          operands[1] = temp;
        }
      operands[1] = t800_force_nonlocal (operands[1]);
    }
  /* to match _fpb32tor64 */
}")

(define_insn "_fpb32tor64"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (unsigned_float:DF (match_operand:SI 1 "nonlocal_operand" "R")))]
  "TARGET_HAVE_FPU"
  "fpb32tor64"
  [(set (attr "popped_inputs") (const_int 2))])


;;------------------------------
;; fixMN2
;;------------------------------

/* Insns of this group on transputers are only able to output to memory.
   Therefore, when asked to generate result in a register, we use a
   dedicated stack slot to perform conversion, and then copy the
   result into the specified register.  */

(define_expand "fixsfsi2"
  [(match_operand:SI 0 "general_operand" "")
   (match_operand:SF 1 "FABCreg_operand" "")]
  "TARGET_HAVE_FPU"
  "{
  rtx t800_temp_slot (enum machine_mode);
  rtx t800_force_nonlocal (rtx);

  rtx dest = operands[0];
  
  if (GET_CODE (dest) != MEM)
    dest = t800_temp_slot (SImode);

  emit_insn (gen__fpstnli32 (t800_force_nonlocal (dest), operands[1]));

  if (dest != operands[0])
    emit_move_insn (operands[0], dest);

  DONE;
}")

(define_expand "fixdfsi2"
  [(match_operand:SI 0 "general_operand" "")
   (match_operand:DF 1 "FABCreg_operand" "")]
  "TARGET_HAVE_FPU"
  "emit_insn (gen_fixsfsi2 (operands[0], operands[1])); DONE;")

(define_expand "fixsfdi2"
  [(match_operand:DI 0 "general_operand" "")
   (match_operand:SF 1 "FABCreg_operand" "")]
  "TARGET_HAVE_FPU"
  "{
  rtx t800_temp_slot (enum machine_mode);
  rtx t800_force_nonlocal (rtx);

  rtx dest = operands[0];
  
  if (GET_CODE (dest) != MEM)
    dest = t800_temp_slot (DImode);

  emit_insn (gen__REAL_to_INT64 (t800_force_nonlocal (dest), operands[1]));

  if (dest != operands[0])
    emit_move_insn (operands[0], dest);

  DONE;
}")

(define_expand "fixdfdi2"
  [(match_operand:DI 0 "general_operand" "")
   (match_operand:DF 1 "FABCreg_operand" "")]
  "TARGET_HAVE_FPU"
  "emit_insn (gen_fixsfdi2 (operands[0], operands[1])); DONE;")


(define_insn "_fpstnli32"
  [(set (match_operand:SI 0 "nonlocal_operand" "=R")
        (fix:SI (match_operand:SF 1 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU"
  "fpstnli32"
  [(set (attr "popped_inputs") (const_int 3))])

(define_insn ""
  [(set (match_operand:SI 0 "nonlocal_operand" "=R")
        (fix:SI (match_operand:DF 1 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU"
  "fpstnli32"
  [(set (attr "popped_inputs") (const_int 3))])


(define_insn "_REAL_to_INT64"
  [(set (match_operand:DI 0 "nonlocal_operand" "=R")
        (fix:DI (match_operand:SF 1 "FABCreg_operand" "t")))
   (clobber (match_scratch:SF 2 "=&f"))
   (clobber (match_scratch:SI 3 "=&r"))]
  "TARGET_HAVE_FPU"
  "* return TARGET_HAVE_FPENTRY ?
    \"fpdup\;dup\;fpstnli32\;ldnlp 1\;fpuexpdec32\;fpstnli32\" :
    \"fpdup\;dup\;fpstnli32\;ldnlp 1\;fpexpdec32\;fpstnli32\";
")

(define_insn ""
  [(set (match_operand:DI 0 "nonlocal_operand" "=R")
        (fix:DI (match_operand:DF 1 "FABCreg_operand" "t")))
   (clobber (match_scratch:SF 2 "=&f"))
   (clobber (match_scratch:SI 3 "=&r"))]
  "TARGET_HAVE_FPU"
  "* return TARGET_HAVE_FPENTRY ?
   \"fpdup\;dup\;fpstnli32\;ldnlp 1\;fpuexpdec32\;fpstnli32\" :
   \"fpdup\;dup\;fpstnli32\;ldnlp 1\;fpexpdec32\;fpstnli32\";"
  [(set (attr "popped_inputs") (const_int 3))])


;;------------------------------
;; fixunsMN2
;;------------------------------
;; N/A

;;------------------------------
;; ftruncM2
;;------------------------------

/* Note that the RTL code <fix:xF> represents a "round-to-zero"
   conversion.  Therefore we should override the default rounding mode
   of transputers, which is "round-to-nearest".  */

(define_expand "ftruncsf2"
  [(set (match_operand:SF 0 "FABCreg_operand" "")
        (fix:SF (match_operand:SF 1 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "if (TARGET_HAVE_FPENTRY) {
     emit_insn (gen__fpurz_fpint_sf (operands[0], operands[1]));
     DONE;
   }
")

(define_expand "ftruncdf2"
  [(set (match_operand:DF 0 "FABCreg_operand" "")
        (fix:DF (match_operand:DF 1 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "if (TARGET_HAVE_FPENTRY) {
     emit_insn (gen__fpurz_fpint_df (operands[0], operands[1]));
     DONE;
   }
")

(define_insn "_fpurz_fpint_sf"
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (fix:SF (match_operand:SF 1 "FABCreg_operand" "0")))
   (clobber (match_scratch:SI 2 "=&r"))]
  "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
  "fpurz\;fpint")

(define_insn "_fpurz_fpint_df"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (fix:DF (match_operand:DF 1 "FABCreg_operand" "0")))
   (clobber (match_scratch:SI 2 "=&r"))]
  "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
  "fpurz\;fpint")

(define_insn ""
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (fix:SF (match_operand:SF 1 "FABCreg_operand" "0")))]
  "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
  "fprz\;fpint")

(define_insn ""
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (fix:DF (match_operand:DF 1 "FABCreg_operand" "0")))]
  "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
  "fprz\;fpint")


;;------------------------------
;; fix_truncMN2
;; fixuns_truncMN2
;;------------------------------
;; N/A


;;------------------------------
;; truncMN2
;;------------------------------

(define_expand "truncdfsf2"
  [(set (match_operand:SF 0 "FABCreg_operand" "")
        (float_truncate:SF (match_operand:DF 1 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "if (TARGET_HAVE_FPENTRY) {
     emit_insn (gen__fpur64tor32 (operands[0], operands[1]));
     DONE;
   }
")

(define_insn "_fpur64tor32"
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (float_truncate:SF (match_operand:DF 1 "FABCreg_operand" "0")))
   (clobber (match_scratch:SI 2 "=&r"))]
  "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
  "fpur64tor32")

(define_insn "_fpr64tor32"
  [(set (match_operand:SF 0 "FABCreg_operand" "=t")
        (float_truncate:SF (match_operand:DF 1 "FABCreg_operand" "0")))]
  "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
  "fpr64tor32")


;;------------------------------
;; extendMN
;;------------------------------

(define_expand "extendqisi2"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (sign_extend:SI (match_operand:QI 1 "general_operand" "")))]
  ""
  "if (! TARGET_HAVE_XTEND) {
     emit_insn (gen__ldc0x80_xword (operands[0], operands[1]));
     DONE;
   }
")

(define_expand "extendhisi2"
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (sign_extend:SI (match_operand:HI 1 "general_operand" "")))]
  ""
  "if (! TARGET_HAVE_XTEND) {
     if (TARGET_HAVE_SIXTEEN) {
       emit_insn (gen__ls_ldc0x8000_xword (operands[0], operands[1]));
     }
     else {
       emit_insn (gen__ldc0x8000_xword (operands[0], 
                                        force_ABCreg (HImode, operands[1])));
     }
     DONE;
   }
")

/* xword requires its argument to be zero-extended to operate
   correctly.  Real trap!  We don't have an easy way to tell if our
   input has been zero-extended already, so we zero-extend here to be
   safe.  Of course, we may end up zero-extending twice; the most
   common case where this can happen is after an `lb', which already
   zero-extends the byte.  We catch these common cases by providing
   special alternatives for them --- works pretty well.  We still get
   superfluous zero extending sometimes, especially when indexing
   signed char arrays (920501-14.c, t800-unknown-parix), but such
   cases are rare.  And modern processors (T450) don't have this
   problem at all, using xbword. */

(define_insn "_ldc0x80_xword"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a,a,a")
        (sign_extend:SI (match_operand:QI 1 "general_operand" "?a,S,R")))
   (clobber (match_scratch:SI 2 "=&r,&r,&r"))]
  "! TARGET_HAVE_XTEND"
  "@
   ldc 0xff\;and\;ldc 0x80\;xword
   ldlp %w1\;lb\;ldc 0x80\;xword
   lb\;ldc 0x80\;xword"
  [(set (attr "popped_inputs") (const_int 2))])

(define_insn "_ls_ldc0x8000_xword"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a,a,a")
        (sign_extend:SI (match_operand:HI 1 "general_operand" "?a,S,R")))
   (clobber (match_scratch:SI 2 "=&r,&r,&r"))]
  "! TARGET_HAVE_XTEND && TARGET_HAVE_SIXTEEN"
  "@
   ldc 0xffff\;and\;ldc 0x8000\;xword
   ldlp %w1\;ls\;ldc 0x8000\;xword
   ls\;ldc 0x8000\;xword"
  [(set (attr "popped_inputs") (const_int 2))])

(define_insn "_ldc0x8000_xword"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (sign_extend:SI (match_operand:HI 1 "ABCreg_operand" "0")))
   (clobber (match_scratch:SI 2 "=&r"))]
  "! TARGET_HAVE_XTEND && ! TARGET_HAVE_SIXTEEN"
  "ldc 0xffff\;and\;ldc 0x8000\;xword")

/* I think we can go with general_operand in insns which load
   something onto regstack: reload should be able to use Areg (which
   is the dest of the insn) for input reload, if one is necessary, so
   this sloppiness won't cause extra spills.  */

(define_insn "_xbword_lbx"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a,a")
        (sign_extend:SI (match_operand:QI 1 "general_operand" "?a,R")))]
  "TARGET_HAVE_XTEND"
  "@
   xbword
   lbx"
  [(set (attr "popped_inputs") (const_int 2))])

(define_insn "_xsword_lsx"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a,a")
        (sign_extend:SI (match_operand:HI 1 "general_operand" "?a,R")))]
  "TARGET_HAVE_XTEND && TARGET_HAVE_SIXTEEN"
  "@
   xsword
   lsx"
  [(set (attr "popped_inputs") (const_int 2))])


(define_insn "extendsidi2"
  [(set (match_operand:DI 0 "ABCreg_operand" "=a")
        (sign_extend:DI (match_operand:SI 1 "ABCreg_operand" "a")))]
  ""
  "xdble"
  [(set (attr "popped_inputs") (const_int 2))])


(define_expand "extendsfdf2"
  [(set (match_operand:DF 0 "FABCreg_operand" "")
        (float_extend:DF (match_operand:SF 1 "FABCreg_operand" "")))]
  "TARGET_HAVE_FPU"
  "if (TARGET_HAVE_FPENTRY) {
     emit_insn (gen__fpur32tor64 (operands[0], operands[1]));
     DONE;
   }
")

(define_insn "_fpur32tor64"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (float_extend:DF (match_operand:SF 1 "FABCreg_operand" "0")))
   (clobber (match_scratch:SI 2 "=&r"))]
  "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
  "fpur32tor64")

(define_insn "_fpr32tor64"
  [(set (match_operand:DF 0 "FABCreg_operand" "=t")
        (float_extend:DF (match_operand:SF 1 "FABCreg_operand" "0")))]
  "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
  "fpr32tor64")


;;------------------------------
;; zero_extendMN
;;------------------------------

(define_expand "zero_extendqisi2"
  [(parallel
    [(set (match_operand:SI 0 "ABCreg_operand" "")
        (zero_extend:SI (match_operand:QI 1 "general_operand" "")))
     (clobber (match_scratch:SI 2 ""))])]
  ""
  "{
    if (GET_CODE (operands[1]) == MEM
        && ! local_operand (operands[1], QImode))
      {
        /* Loading from memory in QImode (`lb') zero-extends the
           loaded byte.  `lb' wants memory address in an ABCreg; Wreg
           and suchlike won't do.  */

        rtx addr = XEXP (operands[1], 0);

        if (! ABCreg_operand (addr, SImode))
          addr = copy_addr_to_reg (addr);

        emit_insn (gen__lb (operands[0], gen_rtx (MEM, QImode, addr)));
        DONE;
      }
    /* The pattern just below will match */
  }")


/* This pattern is capable of using `lb' if the source register fails
   to get a hard reg.  Note that local operand ('S') is always
   word-aligned, so we don't need to go into "ldlp;adc" */

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a,a,a,a")
; ?? general_operand seems to give slightly worse code.
;        (zero_extend:SI (match_operand:QI 1 "general_operand" "R,S,U,a")))
        (zero_extend:SI (match_operand:QI 1 "ABCreg_or_local_operand" "R,S,U,a")))
   (clobber (match_scratch:SI 2 "=X,X,X,&r"))]
  ""
  "@
   lb
   ldlp %w1\;lb
   ldnlp %w1\;lb
   ldc 255\;and"
  [(set (attr "popped_inputs") (const_int 2))])

(define_expand "zero_extendhisi2"
   [(set (match_operand:SI 0 "ABCreg_operand" "")
;         (and:SI (subreg:SI (match_operand:HI 1 "ABCreg_operand" "") 0)
         (and:SI (match_operand:HI 1 "ABCreg_operand" "")
                 (match_dup 2)))]
  ""
  "/* Tried to put subreg in the pattern, but that produced multiple
      subregs if operand1 is already a subreg.  Let gen_lowpart do it right. */
   operands[1] = gen_lowpart (SImode, operands[1]);
   operands[2] = force_reg (SImode, GEN_INT (65535));")


;;------------------------------
;; extv
;; extzv
;; insv
;;------------------------------
;; N/A


;;------------------------------
;; sCOND
;;------------------------------

(define_expand "seq"
  [(match_operand:SI 0 "ABCreg_operand" "")]
  ""
  "t800_expand_scond (EQ, operands[0]); DONE;")

(define_expand "sne"
  [(match_operand:SI 0 "ABCreg_operand" "")]
  ""
  "t800_expand_scond (NE, operands[0]); DONE;")

(define_expand "sle"
  [(match_operand:SI 0 "ABCreg_operand" "")]
  ""
  "t800_expand_scond (LE, operands[0]); DONE;")

(define_expand "slt"
  [(match_operand:SI 0 "ABCreg_operand" "")]
  ""
  "t800_expand_scond (LT, operands[0]); DONE;")

(define_expand "sge"
  [(match_operand:SI 0 "ABCreg_operand" "")]
  ""
  "t800_expand_scond (GE, operands[0]); DONE;")

(define_expand "sgt"
  [(match_operand:SI 0 "ABCreg_operand" "")]
  ""
  "t800_expand_scond (GT, operands[0]); DONE;")

(define_expand "sleu"
  [(match_operand:SI 0 "ABCreg_operand" "")]
  ""
  "t800_expand_scond (LEU, operands[0]); DONE;")

(define_expand "sltu"
  [(match_operand:SI 0 "ABCreg_operand" "")]
  ""
  "t800_expand_scond (LTU, operands[0]); DONE;")

(define_expand "sgeu"
  [(match_operand:SI 0 "ABCreg_operand" "")]
  ""
  "t800_expand_scond (GEU, operands[0]); DONE;")

(define_expand "sgtu"
  [(match_operand:SI 0 "ABCreg_operand" "")]
  ""
  "t800_expand_scond (GTU, operands[0]); DONE;")


/*
 * DEFINE_INSNs for compaisons
 */

(define_insn "_eqc"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (eq:SI (match_operand:SI 1 "ABCreg_operand" "0")
               (match_operand:SI 2 "const_int_operand" "")))]
  ""
  "eqc %2")


(define_insn "_gt"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (gt:SI (match_operand:SI 1 "ABCreg_operand" "b")
               (match_operand:SI 2 "ABCreg_operand" "a")))]
  "T800_DISTINCT_REGS (operands[1], operands[2])"
  "gt"
  [(set (attr "popped_inputs") (const_int 6))])

(define_insn "_gtu"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (gtu:SI (match_operand:SI 1 "ABCreg_operand" "b")
                (match_operand:SI 2 "ABCreg_operand" "a")))]
  "TARGET_HAVE_GTU
   && T800_DISTINCT_REGS (operands[1], operands[2])"
  "gtu"
  [(set (attr "popped_inputs") (const_int 6))])

/* Substract with borrow.  Used in implementation of unsigned
   comparisons on transputers that lack the `gtu' instruction */

(define_insn "_ldiff"
  [(set (match_operand:SI 0 "ABCreg_operand" "=b")
        (ltu:DI
          (zero_extend:DI (match_operand:SI 2 "ABCreg_operand" "b"))
          (plus:DI
            (zero_extend:DI (match_operand:SI 3 "ABCreg_operand" "a"))
            (zero_extend:DI (and:SI
                              (match_operand:SI 4 "ABCreg_operand" "c")
                              (const_int 1))))))
   (set (match_operand:SI 1 "ABCreg_operand" "=a")
        (truncate:SI
          (minus:DI (zero_extend:DI (match_dup 2))
                    (plus:DI (zero_extend:DI (match_dup 3))
                             (zero_extend:DI (and:SI (match_dup 4)
                                                      (const_int 1)))))))]
  "T800_DISTINCT_REGS (operands[2], operands[3])
   && T800_DISTINCT_REGS (operands[3], operands[4])
   && T800_DISTINCT_REGS (operands[2], operands[4])"
  "ldiff"
  [(set (attr "popped_inputs") (const_int 28))])


/* Used to have (eq:SF ...) here, but it would produce unrecognizable
   insn for gen__fpeq (result, DF_operand1, DF_operand2); */

(define_insn "_fpeq"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (eq (match_operand:SF 1 "FABCreg_operand" "%u")
            (match_operand:SF 2 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpeq"
  [(set (attr "popped_inputs") (const_int 6))])

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (eq (match_operand:DF 1 "FABCreg_operand" "%u")
            (match_operand:DF 2 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpeq"
  [(set (attr "popped_inputs") (const_int 6))])


(define_insn "_fpgt"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (gt (match_operand:SF 1 "FABCreg_operand" "u")
            (match_operand:SF 2 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpgt"
  [(set (attr "popped_inputs") (const_int 6))])

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (gt (match_operand:DF 1 "FABCreg_operand" "u")
            (match_operand:DF 2 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpgt"
  [(set (attr "popped_inputs") (const_int 6))])


(define_insn "_fpge"
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (ge (match_operand:SF 1 "FABCreg_operand" "u")
            (match_operand:SF 2 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU
   && TARGET_HAVE_FPGE
   && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpge"
  [(set (attr "popped_inputs") (const_int 6))])

(define_insn ""
  [(set (match_operand:SI 0 "ABCreg_operand" "=a")
        (ge (match_operand:DF 1 "FABCreg_operand" "u")
            (match_operand:DF 2 "FABCreg_operand" "t")))]
  "TARGET_HAVE_FPU
   && TARGET_HAVE_FPGE
   && T800_DISTINCT_REGS (operands[1], operands[2])"
  "fpge"
  [(set (attr "popped_inputs") (const_int 6))])


;;------------------------------
;; bCOND
;;------------------------------

(define_expand "beq"
  [(match_operand 0 "" "")]
  ""
  "t800_expand_bcond (EQ, operands[0]); DONE;")

(define_expand "bne"
  [(match_operand 0 "" "")]
  ""
  "t800_expand_bcond (NE, operands[0]); DONE;")

(define_expand "ble"
  [(match_operand 0 "" "")]
  ""
  "t800_expand_bcond (LE, operands[0]); DONE;")

(define_expand "blt"
  [(match_operand 0 "" "")]
  ""
  "t800_expand_bcond (LT, operands[0]); DONE;")

(define_expand "bge"
  [(match_operand 0 "" "")]
  ""
  "t800_expand_bcond (GE, operands[0]); DONE;")

(define_expand "bgt"
  [(match_operand 0 "" "")]
  ""
  "t800_expand_bcond (GT, operands[0]); DONE;")

(define_expand "bleu"
  [(match_operand 0 "" "")]
  ""
  "t800_expand_bcond (LEU, operands[0]); DONE;")

(define_expand "bltu"
  [(match_operand 0 "" "")]
  ""
  "t800_expand_bcond (LTU, operands[0]); DONE;")

(define_expand "bgeu"
  [(match_operand 0 "" "")]
  ""
  "t800_expand_bcond (GEU, operands[0]); DONE;")

(define_expand "bgtu"
  [(match_operand 0 "" "")]
  ""
  "t800_expand_bcond (GTU, operands[0]); DONE;")


/*
 * DEFINE_INSNs for conditional branches
 */

(define_insn "_cj"
  [(set (pc) (if_then_else (eq:SI (match_operand:SI 1 "ABCreg_operand" "a")
                                  (const_int 0))
                           (label_ref (match_operand 0 "" ""))
                           (pc)))]
  ""
  "cj %l0"
  [(set (attr "popped_inputs") (const_int 2))
   (set (attr "popped_inputs_on_jump") (const_int 0))])

/* Reverse-conditional branch pattern *must* be defined for
   invert_jump() to work properly. */

(define_insn "_inv_cj"
  [(set (pc) (if_then_else (eq:SI (match_operand:SI 1 "ABCreg_operand" "a")
                                  (const_int 0))
                           (pc)
                           (label_ref (match_operand 0 "" ""))))]
  ""
  "eqc 0\;cj %l0"
  [(set (attr "popped_inputs") (const_int 2))
   (set (attr "popped_inputs_on_jump") (const_int 0))])

;;------------------------------
;; call
;; call_value
;;------------------------------

/* operands[0] is the function to call
   operands[1] is the number of args passed on stack;
   operands[2] is next_arg_reg.
   operands[3] is stack_size_rtx  */

(define_expand "call"
  [(match_operand:QI 0 "memory_operand" "")
   (match_operand:SI 1 "" "")
   (match_operand:SI 2 "" "")
   (match_operand:SI 3 "" "")]
  ""
  "t800_expand_call(NULL_RTX, operands[0], operands[1], operands[2],
                    operands[3]); DONE;")

(define_expand "call_value"
; Operand 0 may be any register, including floating ones.
  [(match_operand  0 "register_operand" "")
   (match_operand:QI 1 "memory_operand" "")
   (match_operand:SI 2 "" "")
   (match_operand:SI 3 "" "")
   (match_operand:SI 4 "" "")]
  ""
  "t800_expand_call(operands[0], operands[1], operands[2], operands[3],
                    operands[4]); DONE;")

(define_insn "_call"
  [(set (match_operand 0 "ABCreg_operand" "=a")
        (call (mem:QI (match_operand:SI 1 "immediate_operand" ""))
              (match_operand:SI 2 "" "")))]
  ""
  "*
#ifdef T800_OUTPUT__CALL
  T800_OUTPUT__CALL;
#else
  return \"call %1\";
#endif
")

(define_insn ""
  [(set (match_operand 0 "FABCreg_operand" "=t")
        (call (mem:QI (match_operand:SI 1 "immediate_operand" ""))
              (match_operand:SI 2 "" "")))]
  ""
  "*
#ifdef T800_OUTPUT__CALL
  T800_OUTPUT__CALL;
#else
  return \"call %1\";
#endif
")

/* Unlike `call', `gcall' does not save the return address on the
   stack.  Therefore we do this by hand: calculate the return address
   and push it onto the stack.

   Further, one cannot pass args on registers to gcall, because this
   would leave no room for function address.  FUNCTION_ARG arranges
   for args being passed on stack; but this has its caveat.  When
   callee returns with `ret', it will pop return address and *three
   more words* off the stack; so we have to `ajw' after the call to
   compensate for this.  (Looks strange when this `ajw' happens just
   before `ajw +NNN; ret'.  Use peephole?)

   Note: sizeof(stl 0)==1, sizeof(gcall)==1, hence `ldc 2'.  We could
   do this reliably with labels, but some assemblers (Parix) don't
   handle label substraction well.

   `unspec' in `gcall' pattern makes it differ from the `call' pattern,
   so optimizers won't substitute the latter for the former when gcall
   is used with symbol_ref operand: such substitution would be wrong
   because `call' pushes registers, `gcall' does not.  */

(define_insn "_gcall"
  [(set (match_operand 0 "ABCreg_operand" "=a,a")
        (call (mem:QI (match_operand:SI 1 "nonmemory_operand" "a,i"))
              (match_operand:SI 2 "" "")))
   (unspec [(const_int 0)] 1)]
  ""
  "*
#ifdef T800_OUTPUT__GCALL
  T800_OUTPUT__GCALL;
#else
  return which_alternative ? \"ajw -1\;ldc 2\;ldpi\;stl 0\;j %1\;ajw -3\"
                           : \"ajw -1\;ldc 2\;ldpi\;stl 0\;gcall\;ajw -3\";
#endif
"
  [(set (attr "popped_inputs") (const_int 2))])

(define_insn ""
  [(set (match_operand 0 "FABCreg_operand" "=t,t")
        (call (mem:QI (match_operand:SI 1 "nonmemory_operand" "a,i"))
              (match_operand:SI 2 "" "")))
   (unspec [(const_int 0)] 1)]
  ""
  "*
#ifdef T800_OUTPUT__GCALL
  T800_OUTPUT__GCALL;
#else
  return which_alternative ? \"ajw -1\;ldc 2\;ldpi\;stl 0\;j %1\;ajw -3\"
                           : \"ajw -1\;ldc 2\;ldpi\;stl 0\;gcall\;ajw -3\";
#endif
"
  [(set (attr "popped_inputs") (const_int 2))])

/* _gcall_aggregate is a variation of normal _gcall used for models
   which pass struct return address in Areg, so that function address
   has to come in Breg instead. */

(define_insn "_gcall_aggregate"
  [(set (match_operand 0 "ABCreg_operand" "=a,a")
        (call:CC (mem:QI (match_operand:SI 1 "nonmemory_operand" "b,i"))
                 (match_operand:SI 2 "" "")))
   (unspec [(const_int 0)] 2)]
  ""
  "*
#ifdef T800_OUTPUT__GCALL
  T800_OUTPUT__GCALL;
#else
  return which_alternative ? \"ajw -1\;ldc 2\;ldpi\;stl 0\;j %1\;ajw -3\"
                           : \"ajw -1\;ldc 2\;ldpi\;stl 0\;gcall\;ajw -3\";
#endif
"
  [(set (attr "popped_inputs") (const_int 2))])


;;------------------------------
;; call_pop
;; call_value_pop
;;------------------------------
;; N/A


;;------------------------------
;; return
;;------------------------------

/* We have to use `return' pattern rather than jump to epilogue, as
   the jump insn clobbers all stack regs, including the one that
   carries a return value.  */

(define_insn "return"
  [(return)]
  ""
  "*
  T800_OUTPUT_RETURN;
")

;;------------------------------
;; nop
;;------------------------------

(define_insn "nop"
  [(const_int 0)]
  ""
  "*
#ifdef T800_OUTPUT_NOP
  T800_OUTPUT_NOP;
#else
  return \"pfix 0\";
#endif
")

;;------------------------------
;; jump
;;------------------------------

/* The `j' insn may cause descheduling of current process, which does
   not preserve any reg besides Iptr and Wreg. */

(define_insn "jump"
  [(set (pc) (label_ref (match_operand 0 "" "")))
   (clobber (reg:SI 0))
   (clobber (reg:SI 1))
   (clobber (reg:SI 2))
   (clobber (reg:SF 3))
   (clobber (reg:SF 4))
   (clobber (reg:SF 5))]
  ""
  "j %l0")

;;------------------------------
;; indirect_jump
;;------------------------------

/* JUMP_INSNs are not allowed to have output reloads. To be compliant
   with this requirement, we have to use

     (clobber (match_dup 0))  rather than
     (set (match_dup 0) (pc))

   The old value of (pc) isn't likely to be used anyway.  */

(define_insn "indirect_jump"
  [(set (pc) (match_operand:SI 0 "ABCreg_operand" "a"))
   (clobber (match_dup 0))]
  ""
  "gcall")

;;------------------------------
;; casesi
;;------------------------------

/* Some points to explain why tablejumping is not so easy on transputers.

   1. We cannot use absolute casetables because on Parix there are no
      load-time fixups: by definition .word Lxxx initializes the word
      with the *offset* from the beginning of the text segment to
      Lxxx, not with the absolute address of Lxxx.  So we must use
      relative casetables, and have `ldpi' in tablejump or equivalent
      to convert the offset fetched from the table into an address to
      `gcall' to.

   2. We must insert .align 4 before the table because word accesses
      only work at a word boundary.  Therefore we have a gap of
      uncertain length between `ldpi;gcall' and the table label.
      So the distance from ldpi to table_label is nonconstant (until
      assembling, of course, but that doesn't help).

   3. We could use `adc ldpi_label-table_label' before lpdi to
      compensate for the gap.  But Parix assembler dives a warning on
      label difference arguments to adc.

   4. Output reloads can break neighbourhood of ldpi and the
      code_label emitted just after it, if the label is made a
      separate insn.

   We use casesi instead of tablejump to be able to do a trick.  We
   want to use two labels instead of single table_label.  One label
   (table_label) is placed just before the table as usual, and is used
   to access the table.  The other label (table_rel_label) is the label
   which offsets are relative to, and it is placed after a ldpi in the
   jumping code.

   This two-label scheme saves us an adc -- in addition, an adc with a
   label-difference argument which causes a warning (!?) on certain
   assemblers... Parix, right.

   Here is what we want to generate:

        [normalize index, check bounds, scale to word offset,
         compute table elt address and then...]
	ldnl 0
        ldpi
table_rel_label:
        gcall
        .align 4
table_label:
        .word Lcase1-table_rel_label
        .word Lcase2-table_rel_label
	...

   Note that table_rel_label does not exist as a separate insn, but is
   generated as a permutation of table_label in final pass.  (Making
   table_rel_label a separate insn is not good because this would cut
   the tablejumping code in two separate basic blocks, which hinders
   optimization).  But hiding the table_rel_label, in turn, poses a
   problem: on some patological programs (920917-1.c is an example)
   optimizers may delete the tablejump insn (which is responsible for
   outputting table_rel_label) but leaving the table intact.  The
   resulting code is not assemblable because the table refers to
   table_rel_label, which does not exist.

   We work around this problem by having the tablejump output routine
   recording the label number in t800_expect_table_label, and
   suppressing ASM_OUTPUT_ADDR_DIFF_ELT if the recorded label number
   doesn't match one of the table being output.  The proper fix would
   be to make GCC optimize away either both table jump and the table,
   or none of them... but I don't feel brave enough at the moment. ;-)  */

(define_expand "casesi"
  [(match_operand:SI 0 "ABCreg_operand" "a")	; index
   (match_operand:SI 1 "const_int_operand" "")	; lower bound
   (match_operand:SI 2 "const_int_operand" "")	; highest index in table
   (match_operand:SI 3 "" "")			; table_label
   (match_operand:SI 4 "" "")]			; default_label
  ""
  "{
#define INDEX operands[0]
#define LOWER_BOUND operands[1]
#define HIGHEST_INDEX operands[2]
#define TABLE_LABEL operands[3]
#define DEFAULT_LABEL operands[4]

  rtx table_index = gen_reg_rtx (SImode);

  emit_insn (gen__adc (table_index, INDEX, GEN_INT (- INTVAL (LOWER_BOUND))));

  /* mimic two lines from do_tablejump */
  emit_cmp_insn (table_index, HIGHEST_INDEX, GTU, NULL_RTX, SImode, 1, 0);
  emit_jump_insn (gen_bgtu (DEFAULT_LABEL));

  emit_jump_insn (gen__my_fancy_tablejump (table_index, TABLE_LABEL));

  DONE;
#undef INDEX
#undef LOWER_BOUND
#undef HIGHEST_INDEX
#undef TABLE_LABEL
#undef DEFAULT_LABEL
}")

(define_insn "_my_fancy_tablejump"
  [(set (pc)
        (plus:SI (label_ref:SI (match_operand 1 "" ""))
                 (mem:SI
                   (plus:SI (label_ref:SI (match_dup 1))
                            (mult:SI (match_operand:SI 0 "ABCreg_operand" "a")
                                     (const_int 4))))))
; The clobber below would help us to be 100% correct: this insn
; actually replaces its arg with... hmmm... some other value, and we
; should let the compiler know about this.  But adding this clobber
; scares cse and it fails to optimize the switching code in the case
; of index expression being a constant.  Therefore I leave the clobber
; out; I cannot imagine a situation where the compiler could try to
; reuse the table index which is allegedly left in Areg.
;   (clobber (match_dup 0))

   (clobber (match_scratch:SI 2 "=&r"))
  ]
  ""
  "*{
  /* Leave a note for ASM_OUTPUT_ADDR_DIFF_ELT */
  extern int t800_expected_table_label;
  t800_expected_table_label = CODE_LABEL_NUMBER (operands[1]);

#ifdef T800_LDC_SYMBOL_PC_RELATIVE
  return \"ldc %1-2\;ldpi\;wsub\;ldnl 0\;ldpi\\n%1a:\;gcall\";
#else
  return \"ldc %1-LF%=\;ldpi\\nLF%=:\;wsub\;ldnl 0\;ldpi\\n%1a:\;gcall\";
#endif
}")

;;------------------------------
;; tablejump
;;------------------------------

; we use casesi now

;;------------------------------
;; allocate_stack
;;------------------------------

(define_expand "allocate_stack"
  [(match_operand:SI 0 "general_operand" "")]
  ""
  "
#ifdef T800_EXPAND_ALLOCATE_STACK
  T800_EXPAND_ALLOCATE_STACK;
#else /* not T800_EXPAND_ALLOCATE_STACK */
{
    rtx size;

    /* Increase the adjustment requested by the space necessary for
       (1) firmware reserved area below Wreg (2) save slot where the
       normal value of Wreg is saved during calls and (3) outgoing args */
    if (GET_CODE (operands[0]) == CONST_INT) {
      size = GEN_INT (INTVAL (operands[0])
                      + WORKSPACE_RESERVED_BYTES
                      + UNITS_PER_WORD  /* save slot */
                      + WORD_ROUND (current_function_outgoing_args_size));
    }
    else {
      size = gen_rtx (PLUS, Pmode,
                      operands[0],
                      GEN_INT (WORKSPACE_RESERVED_BYTES
                               + UNITS_PER_WORD  /* save slot */
                               + WORD_ROUND (current_function_outgoing_args_size)));
    }
    anti_adjust_stack (size);
    DONE;
}
#endif /* not T800_EXPAND_ALLOCATE_STACK */
")

;;--------------------------------------------------------------------------
;; peephole optimization definitions
;;--------------------------------------------------------------------------

/* get rid of unnecessary stack reordering sometimes generated by
   stack-reg converter.  We could try to make the converter smarter to
   avoid generating this, but it seems simpler to leave it as it is and
   remove the redundancy with peephole optimizer.  */

/* dup; ldc NNN; stl -1; rev; ldl -1  =>  dup; ldc NNN */

(define_peephole
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (match_operand:SI 1 "ABCreg_operand" ""))
   (set (match_operand:SI 2 "ABCreg_operand" "")
        (match_operand:SI 3 "const_int_operand" ""))
   (set (mem:SI (plus:SI (reg:SI 6) (const_int -4)))
        (match_operand:SI 4 "ABCreg_operand" ""))
   (parallel[(set (match_operand:SI 5 "ABCreg_operand" "")
                  (match_operand:SI 6 "ABCreg_operand" ""))
             (set (match_dup 6)
                  (match_dup 5))])
   (set (match_operand:SI 7 "ABCreg_operand" "")
        (mem:SI (plus:SI (reg:SI 6) (const_int -4))))]
  ""
  "*return INTVAL (operands[1]) == 0x80000000
      ? \"dup\;mint\"
      : \"dup\;ldc %3\";
")

/* dup; ldl NNN; stl -1; rev; ldl -1  =>  dup; ldl NNN */

(define_peephole
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (match_operand:SI 1 "ABCreg_operand" ""))
   (set (match_operand:SI 2 "ABCreg_operand" "")
        (match_operand:SI 3 "local_operand" ""))
   (set (mem:SI (plus:SI (reg:SI 6) (const_int -4)))
        (match_operand:SI 4 "ABCreg_operand" ""))
   (parallel[(set (match_operand:SI 5 "ABCreg_operand" "")
                  (match_operand:SI 6 "ABCreg_operand" ""))
             (set (match_dup 6)
                  (match_dup 5))])
   (set (match_operand:SI 7 "ABCreg_operand" "")
        (mem:SI (plus:SI (reg:SI 6) (const_int -4))))]
  ""
  "dup\;ldl %w3")

/* ldc NNN; stl -1; rev; ldl -1  =>  rev; ldc NNN */

(define_peephole
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (match_operand:SI 1 "const_int_operand" ""))
   (set (mem:SI (plus:SI (reg:SI 6) (const_int -4)))
        (match_operand:SI 2 "ABCreg_operand" ""))
   (parallel[(set (match_operand:SI 3 "ABCreg_operand" "")
                  (match_operand:SI 4 "ABCreg_operand" ""))
             (set (match_dup 4)
                  (match_dup 3))])
   (set (match_operand:SI 5 "ABCreg_operand" "")
        (mem:SI (plus:SI (reg:SI 6) (const_int -4))))]
  ""
  "*return INTVAL (operands[1]) == 0x80000000
      ? \"rev\;mint\"
      : \"rev\;ldc %1\";
")

/* ldl NNN; stl -1; rev; ldl -1  =>  rev; ldl NNN */

(define_peephole
  [(set (match_operand:SI 0 "ABCreg_operand" "")
        (match_operand:SI 1 "local_operand" ""))
   (set (mem:SI (plus:SI (reg:SI 6) (const_int -4)))
        (match_operand:SI 2 "ABCreg_operand" ""))
   (parallel[(set (match_operand:SI 3 "ABCreg_operand" "")
                  (match_operand:SI 4 "ABCreg_operand" ""))
             (set (match_dup 4)
                  (match_dup 3))])
   (set (match_operand:SI 5 "ABCreg_operand" "")
        (mem:SI (plus:SI (reg:SI 6) (const_int -4))))]
  ""
  "rev\;ldl %w1")
